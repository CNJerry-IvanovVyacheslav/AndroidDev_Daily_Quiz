[
  {
    "id": 1,
    "question": "Which keyword is used to declare a read-only variable in Kotlin?",
    "answer": "val",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "var",
      "const",
      "let",
      "readonly",
      "val"
    ]
  },
  {
    "id": 2,
    "question": "What is the default visibility modifier for a top-level declaration in Kotlin?",
    "answer": "public",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "private",
      "internal",
      "protected",
      "default",
      "public"
    ]
  },
  {
    "id": 3,
    "question": "Which of these is a correct way to define a function in Kotlin?",
    "answer": "fun sum(a: Int, b: Int): Int { return a + b }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "function sum(a: Int, b: Int) = a + b",
      "def sum(a: Int, b: Int) { a + b }",
      "fun sum(a: Int, b: Int): Int { return a + b }",
      "func sum(a, b) -> Int { return a + b }",
      "fun sum(a: Int, b: Int) a + b"
    ]
  },
  {
    "id": 4,
    "question": "How do you define a nullable variable in Kotlin?",
    "answer": "var name: String?",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "var name: String!",
      "var name: String",
      "var name: String?",
      "var name nullable String",
      "var name: nullable String"
    ]
  },
  {
    "id": 5,
    "question": "Which function is used to safely call a method on a nullable object?",
    "answer": "?.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      ".",
      "!!",
      "?:",
      "?.",
      "safeCall()"
    ]
  },
  {
    "id": 6,
    "question": "What does the 'lateinit' keyword do?",
    "answer": "Allows a non-null variable to be initialized later",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Declares a lazy variable",
      "Allows a non-null variable to be initialized later",
      "Marks a variable as immutable",
      "Declares a nullable variable",
      "Forces immediate initialization"
    ]
  },
  {
    "id": 7,
    "question": "Which of these is a correct way to define a singleton object in Kotlin?",
    "answer": "object DatabaseManager",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "class DatabaseManager { static val instance = ... }",
      "object DatabaseManager",
      "singleton DatabaseManager",
      "DatabaseManager.getInstance()",
      "val DatabaseManager = singleton()"
    ]
  },
  {
    "id": 8,
    "question": "What is the purpose of the 'companion object' in Kotlin?",
    "answer": "To define members belonging to the class rather than instances",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "To define a nested class",
      "To define members belonging to the class rather than instances",
      "To define a data class",
      "To implement an interface",
      "To define extension functions"
    ]
  },
  {
    "id": 9,
    "question": "Which of these keywords is used for inheritance in Kotlin?",
    "answer": "open",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "final",
      "inherit",
      "abstract",
      "open",
      "extends"
    ]
  },
  {
    "id": 10,
    "question": "Which type of class cannot be inherited in Kotlin?",
    "answer": "final",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "abstract",
      "interface",
      "open",
      "final",
      "sealed"
    ]
  },
  {
    "id": 11,
    "question": "What is the difference between '=='' and '===' in Kotlin?",
    "answer": "'==' checks structural equality, '===' checks referential equality",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "'==' checks referential equality, '===' checks structural equality",
      "'==' checks structural equality, '===' checks referential equality",
      "They are interchangeable",
      "'==' is for numbers, '===' is for objects",
      "None of the above"
    ]
  },
  {
    "id": 12,
    "question": "How do you define a data class in Kotlin?",
    "answer": "data class User(val name: String, val age: Int)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "class data User(val name: String, val age: Int)",
      "data class User(val name: String, val age: Int)",
      "data User(val name: String, val age: Int)",
      "User data class(val name: String, val age: Int)",
      "class User data(val name: String, val age: Int)"
    ]
  },
  {
    "id": 13,
    "question": "Which of these keywords defines a sealed class in Kotlin?",
    "answer": "sealed",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "sealed",
      "open",
      "abstract",
      "final",
      "interface"
    ]
  },
  {
    "id": 14,
    "question": "What is the result of 'listOf(1,2,3).filter { it > 1 }'?",
    "answer": "[2, 3]",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "[1]",
      "[1,2,3]",
      "[2,3]",
      "[1,3]",
      "Error"
    ]
  },
  {
    "id": 15,
    "question": "Which Kotlin collection is mutable by default?",
    "answer": "MutableList",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "List",
      "Array",
      "MutableList",
      "Set",
      "Map"
    ]
  },
  {
    "id": 16,
    "question": "What does 'by lazy' do in Kotlin?",
    "answer": "Initializes the value when first accessed",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Initializes the value immediately",
      "Initializes the value when first accessed",
      "Marks a variable as immutable",
      "Creates a nullable variable",
      "None of the above"
    ]
  },
  {
    "id": 17,
    "question": "How do you define an extension function?",
    "answer": "fun String.isPalindrome(): Boolean { ... }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "extension fun String.isPalindrome(): Boolean { ... }",
      "fun String.isPalindrome(): Boolean { ... }",
      "fun isPalindrome(str: String): Boolean { ... }",
      "String.fun isPalindrome(): Boolean { ... }",
      "fun String.isPalindrome { ... }"
    ]
  },
  {
    "id": 18,
    "question": "What is the difference between 'val' and 'var'?",
    "answer": "val is immutable, var is mutable",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "val is mutable, var is immutable",
      "val is immutable, var is mutable",
      "Both are mutable",
      "Both are immutable",
      "None of the above"
    ]
  },
  {
    "id": 19,
    "question": "Which of these is a correct way to create a singleton using 'object'?",
    "answer": "object Logger { fun log(msg: String) {} }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "class Logger { fun log(msg: String) {} }",
      "object Logger { fun log(msg: String) {} }",
      "singleton Logger { fun log(msg: String) {} }",
      "Logger.getInstance()",
      "val Logger = singleton()"
    ]
  },
  {
    "id": 20,
    "question": "What does the 'is' operator do?",
    "answer": "Checks type at runtime",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Assigns a type",
      "Checks type at runtime",
      "Casts type",
      "Creates a new instance",
      "None of the above"
    ]
  },
  {
    "id": 21,
    "question": "Which function can be used to launch a coroutine in Kotlin?",
    "answer": "launch",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "startCoroutine",
      "run",
      "launch",
      "asyncBlock",
      "delay"
    ]
  },
  {
    "id": 22,
    "question": "Which of these is a correct way to create a mutable map?",
    "answer": "mutableMapOf(\"a\" to 1, \"b\" to 2)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "mapOf(\"a\" to 1, \"b\" to 2)",
      "mutableMapOf(\"a\" to 1, \"b\" to 2)",
      "Map(\"a\" -> 1, \"b\" -> 2)",
      "HashMap(\"a\",1,\"b\",2)",
      "mutableMap(\"a\" to 1, \"b\" to 2)"
    ]
  },
  {
    "id": 23,
    "question": "Which keyword is used to delegate a property in Kotlin?",
    "answer": "by",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "delegate",
      "using",
      "by",
      "with",
      "implements"
    ]
  },
  {
    "id": 24,
    "question": "What is the type of 'numbers.filter { it % 2 == 0 }' if numbers: List<Int>?",
    "answer": "List<Int>",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "List<Boolean>",
      "List<Int>",
      "Sequence<Int>",
      "Array<Int>",
      "IntArray"
    ]
  },
  {
    "id": 25,
    "question": "Which of these is a correct way to define a higher-order function?",
    "answer": "fun operate(a: Int, b: Int, op: (Int, Int) -> Int) = op(a, b)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "fun operate(a: Int, b: Int, op: (Int, Int) -> Int) = op(a, b)",
      "fun operate(a: Int, b: Int): (Int, Int) -> Int = op(a, b)",
      "fun operate(a: Int, b: Int, op: Int -> Int) = op(a, b)",
      "fun operate(a: Int, b: Int) op: (Int, Int) -> Int = op(a, b)",
      "operate(a: Int, b: Int, op: (Int, Int) -> Int)"
    ]
  },
  {
    "id": 26,
    "question": "Which function converts a collection to a sequence in Kotlin?",
    "answer": "asSequence()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "toSequence()",
      "sequenceOf()",
      "asSequence()",
      "toSeq()",
      "seq()"
    ]
  },
  {
    "id": 27,
    "question": "What happens if you use '!!' on a null variable?",
    "answer": "Throws a KotlinNullPointerException",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Returns null",
      "Throws a KotlinNullPointerException",
      "Assigns a default value",
      "Converts it to zero",
      "No effect"
    ]
  },
  {
    "id": 28,
    "question": "How do you define an inline function?",
    "answer": "inline fun myFunc() { }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "fun inline myFunc() { }",
      "inline fun myFunc() { }",
      "func inline myFunc() { }",
      "inline function myFunc() { }",
      "myFunc inline fun() { }"
    ]
  },
  {
    "id": 29,
    "question": "Which of these is a correct way to use a lambda expression?",
    "answer": "listOf(1,2,3).map { it * 2 }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "listOf(1,2,3).map { it * 2 }",
      "map(listOf(1,2,3)) { it * 2 }",
      "listOf(1,2,3).forEach(it * 2)",
      "listOf(1,2,3).lambda(it * 2)",
      "listOf(1,2,3).apply { it * 2 }"
    ]
  },
  {
    "id": 30,
    "question": "Which keyword is used to define an interface in Kotlin?",
    "answer": "interface",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "interface",
      "abstract",
      "implements",
      "trait",
      "class"
    ]
  },
  {
    "id": 31,
    "question": "What is a correct way to declare a function with a default parameter value?",
    "answer": "fun greet(name: String = \"Guest\") { ... }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "fun greet(name: String = \"Guest\") { ... }",
      "fun greet(name = \"Guest\") { ... }",
      "fun greet(default name: \"Guest\") { ... }",
      "fun greet(name: String? = \"Guest\") { ... }",
      "fun greet(name = \"Guest\") { ... }"
    ]
  },
  {
    "id": 32,
    "question": "Which of these creates a range from 1 to 10 inclusive?",
    "answer": "1..10",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "1..10",
      "1 until 10",
      "range(1,10)",
      "1->10",
      "1-10"
    ]
  },
  {
    "id": 33,
    "question": "Which coroutine builder can be used to return a value?",
    "answer": "async",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "launch",
      "runBlocking",
      "async",
      "delay",
      "suspend"
    ]
  },
  {
    "id": 34,
    "question": "Which of these is a correct way to implement a sealed class?",
    "answer": "sealed class Expr; class Const(val number: Int) : Expr()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "sealed class Expr; class Const(val number: Int) : Expr()",
      "abstract class Expr; class Const(val number: Int): Expr()",
      "class Expr; sealed class Const(val number: Int) : Expr()",
      "sealed interface Expr; class Const(val number: Int) : Expr()",
      "sealed class Expr(val number: Int)"
    ]
  },
  {
    "id": 35,
    "question": "What does the 'apply' scope function return?",
    "answer": "The receiver object",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "The last expression",
      "The receiver object",
      "Unit",
      "A lambda result",
      "Nothing"
    ]
  },
  {
    "id": 36,
    "question": "Which operator is known as the Elvis operator in Kotlin?",
    "answer": "?:",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      ":",
      "!!",
      "?:",
      "??",
      "?."
    ]
  },
  {
    "id": 37,
    "question": "Which of these correctly defines a generic function?",
    "answer": "fun <T> singletonList(item: T): List<T> = listOf(item)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "fun <T> singletonList(item: T): List<T> = listOf(item)",
      "fun singletonList<T>(item: T): List<T> = listOf(item)",
      "fun singletonList(item: T): List<T> = listOf(item)",
      "fun <T> singletonList(item): List<T> = listOf(item)",
      "fun singletonList<T>(item: T) = listOf(item)"
    ]
  },
  {
    "id": 38,
    "question": "Which of these is a correct way to define an enum class?",
    "answer": "enum class Direction { NORTH, SOUTH, EAST, WEST }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "enum Direction { NORTH, SOUTH }",
      "enum class Direction { NORTH, SOUTH, EAST, WEST }",
      "enum class Direction(NORTH, SOUTH, EAST, WEST)",
      "enum Direction(NORTH, SOUTH)",
      "Direction.enum { NORTH, SOUTH }"
    ]
  },
  {
    "id": 39,
    "question": "What does 'suspend' keyword indicate?",
    "answer": "Function can be paused and resumed in coroutine",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Function is asynchronous",
      "Function can be paused and resumed in coroutine",
      "Function is deprecated",
      "Function runs on background thread",
      "Function is inline"
    ]
  },
  {
    "id": 40,
    "question": "Which function is used to launch a coroutine and block current thread until it completes?",
    "answer": "runBlocking",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "launch",
      "async",
      "delay",
      "runBlocking",
      "withContext"
    ]
  },
  {
    "id": 41,
    "question": "Which of these can throw ConcurrentModificationException in Kotlin?",
    "answer": "Iterating a mutable collection while modifying it",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Iterating an immutable collection",
      "Iterating a mutable collection while modifying it",
      "Filtering a list",
      "Sorting a list",
      "Mapping a list"
    ]
  },
  {
    "id": 42,
    "question": "Which of these is a correct example of a lambda with receiver?",
    "answer": "val result = buildString { append(\"Hello\") }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "val result = buildString { append(\"Hello\") }",
      "val result = { receiver -> append(\"Hello\") }",
      "val result = { this.append(\"Hello\") }",
      "val result = lambda { append(\"Hello\") }",
      "val result = run { append(\"Hello\") }"
    ]
  },
  {
    "id": 43,
    "question": "Which of these is used to check null and provide default value?",
    "answer": "?:",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "!!",
      "as?",
      "?:",
      "?.",
      "ifnull"
    ]
  },
  {
    "id": 44,
    "question": "How to declare a typealias in Kotlin?",
    "answer": "typealias UserMap = Map<String, User>",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "alias UserMap = Map<String, User>",
      "typealias UserMap = Map<String, User>",
      "typedef UserMap = Map<String, User>",
      "using UserMap = Map<String, User>",
      "type UserMap = Map<String, User>"
    ]
  },
  {
    "id": 45,
    "question": "Which scope function returns the last expression and provides 'this' as the context object?",
    "answer": "run",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "apply",
      "let",
      "with",
      "run",
      "also"
    ]
  },
  {
    "id": 46,
    "question": "Which function is used to launch a coroutine on the IO dispatcher?",
    "answer": "withContext(Dispatchers.IO) { ... }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "launch(IO) { ... }",
      "runBlocking(IO) { ... }",
      "async(IO) { ... }",
      "withContext(Dispatchers.IO) { ... }",
      "launch { Dispatchers.IO }"
    ]
  },
  {
    "id": 47,
    "question": "Which of these is a correct way to sort a list descending?",
    "answer": "list.sortedDescending()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "list.sortDescending()",
      "list.sortedDescending()",
      "list.orderByDescending()",
      "list.sortedByDescending()",
      "list.descending()"
    ]
  },
  {
    "id": 48,
    "question": "Which of these correctly destructures a data class?",
    "answer": "val (name, age) = user",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "val name, age = user",
      "val (name, age) = user",
      "val name = user.name, age = user.age",
      "val (user.name, user.age)",
      "destructure(user)"
    ]
  },
  {
    "id": 49,
    "question": "Which of these creates an immutable list?",
    "answer": "listOf(1,2,3)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "mutableListOf(1,2,3)",
      "arrayListOf(1,2,3)",
      "listOf(1,2,3)",
      "List(1,2,3)",
      "ImmutableList(1,2,3)"
    ]
  },
  {
    "id": 50,
    "question": "Which of these is the correct syntax for a when expression?",
    "answer": "when(x) { 1 -> print(\"One\") else -> print(\"Other\") }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "switch(x) { case 1: print(\"One\") default: print(\"Other\") }",
      "when(x) { 1 -> print(\"One\") else -> print(\"Other\") }",
      "when(x) { case 1 -> print(\"One\") default -> print(\"Other\") }",
      "when x { 1 -> print(\"One\") else -> print(\"Other\") }",
      "when { x==1 -> print(\"One\") else -> print(\"Other\") }"
    ]
  },
  {
    "id": 51,
    "question": "Which class is used to store UI-related data that survives configuration changes?",
    "answer": "ViewModel",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LiveData",
      "Repository",
      "Activity",
      "ViewModel",
      "Service"
    ]
  },
  {
    "id": 52,
    "question": "Which Kotlin Flow type can emit events to multiple collectors?",
    "answer": "SharedFlow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LiveData",
      "StateFlow",
      "Flow",
      "SharedFlow",
      "MutableLiveData"
    ]
  },
  {
    "id": 53,
    "question": "Which Jetpack library is used for navigation between destinations?",
    "answer": "Navigation Component",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Navigation Component",
      "Paging",
      "WorkManager",
      "DataStore",
      "Room"
    ]
  },
  {
    "id": 54,
    "question": "What is Safe Args used for?",
    "answer": "Type-safe argument passing between destinations",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Database queries",
      "Type-safe argument passing between destinations",
      "Networking",
      "Dependency Injection",
      "UI testing"
    ]
  },
  {
    "id": 55,
    "question": "Which component can perform background tasks with constraints like network availability?",
    "answer": "WorkManager",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Service",
      "IntentService",
      "WorkManager",
      "Thread",
      "Handler"
    ]
  },
  {
    "id": 56,
    "question": "Which Jetpack component is lifecycle-aware and can observe Activity/Fragment lifecycle?",
    "answer": "LifecycleObserver",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LiveData",
      "ViewModel",
      "LifecycleObserver",
      "CoroutineScope",
      "Repository"
    ]
  },
  {
    "id": 57,
    "question": "Which class provides a reactive data holder that updates the UI automatically?",
    "answer": "LiveData",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LiveData",
      "StateFlow",
      "MutableState",
      "Flow",
      "ViewModel"
    ]
  },
  {
    "id": 58,
    "question": "Which component is recommended for paging large datasets in RecyclerView?",
    "answer": "Paging",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Room",
      "Paging",
      "DataStore",
      "WorkManager",
      "Navigation"
    ]
  },
  {
    "id": 59,
    "question": "Which Jetpack component is designed for asynchronous local data storage?",
    "answer": "DataStore",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "SharedPreferences",
      "DataStore",
      "Room",
      "SQLiteDatabase",
      "ContentProvider"
    ]
  },
  {
    "id": 60,
    "question": "Which annotation defines a database entity in Room?",
    "answer": "@Entity",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Entity",
      "@Database",
      "@Dao",
      "@Module",
      "@Provides"
    ]
  },
  {
    "id": 61,
    "question": "Which annotation defines a Data Access Object (DAO) in Room?",
    "answer": "@Dao",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Dao",
      "@Entity",
      "@Database",
      "@Repository",
      "@Inject"
    ]
  },
  {
    "id": 62,
    "question": "Which component provides lifecycle-aware coroutine scopes tied to ViewModel?",
    "answer": "viewModelScope",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "lifecycleScope",
      "GlobalScope",
      "viewModelScope",
      "runBlocking",
      "CoroutineScope"
    ]
  },
  {
    "id": 63,
    "question": "Which annotation is used to mark a Room database class?",
    "answer": "@Database",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Entity",
      "@Database",
      "@Dao",
      "@Module",
      "@Provides"
    ]
  },
  {
    "id": 64,
    "question": "Which class allows you to observe database changes reactively?",
    "answer": "Flow or LiveData from DAO",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Cursor",
      "Flow or LiveData from DAO",
      "PagingSource",
      "WorkManager",
      "ViewModel"
    ]
  },
  {
    "id": 65,
    "question": "Which component allows navigation to destinations using deep links?",
    "answer": "Navigation Component",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Intent",
      "Navigation Component",
      "Activity",
      "BroadcastReceiver",
      "Service"
    ]
  },
  {
    "id": 66,
    "question": "Which design pattern is commonly used to ensure that only one instance of a repository exists throughout the app?",
    "answer": "Singleton Repository",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "ViewModel",
      "LiveData",
      "Singleton Repository",
      "WorkManager",
      "Service"
    ]
  },
  {
    "id": 67,
    "question": "Which component is used to schedule deferred, periodic, or one-off tasks?",
    "answer": "WorkManager",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Service",
      "Thread",
      "Handler",
      "WorkManager",
      "Coroutine"
    ]
  },
  {
    "id": 68,
    "question": "Which Jetpack component automatically handles configuration changes?",
    "answer": "ViewModel",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Activity",
      "Fragment",
      "ViewModel",
      "LiveData",
      "Service"
    ]
  },
  {
    "id": 69,
    "question": "Which Kotlin Flow type holds a current value and emits it to new collectors immediately?",
    "answer": "StateFlow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "SharedFlow",
      "Flow",
      "LiveData",
      "StateFlow",
      "Channel"
    ]
  },
  {
    "id": 70,
    "question": "Which annotation is used to inject dependencies in Hilt/Dagger for Jetpack components?",
    "answer": "@Inject",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Provides",
      "@Module",
      "@Singleton",
      "@Inject",
      "@Component"
    ]
  },
  {
    "id": 71,
    "question": "Which annotation defines a Hilt module?",
    "answer": "@Module",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Module",
      "@Provides",
      "@Inject",
      "@Singleton",
      "@Component"
    ]
  },
  {
    "id": 72,
    "question": "Which annotation marks a class as a singleton in Hilt/Dagger?",
    "answer": "@Singleton",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Singleton",
      "@Module",
      "@Inject",
      "@Provides",
      "@Component"
    ]
  },
  {
    "id": 73,
    "question": "Which class in Jetpack handles UI-related data and survives process death when using SavedStateHandle?",
    "answer": "ViewModel",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Activity",
      "LiveData",
      "ViewModel",
      "Service",
      "Repository"
    ]
  },
  {
    "id": 74,
    "question": "Which Jetpack component provides reactive streams of data for UI updates?",
    "answer": "LiveData or Flow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LiveData or Flow",
      "ViewModel",
      "Service",
      "Handler",
      "BroadcastReceiver"
    ]
  },
  {
    "id": 75,
    "question": "Which Jetpack component supports type-safe navigation arguments?",
    "answer": "Safe Args",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Intent extras",
      "Bundle",
      "Safe Args",
      "SharedPreferences",
      "Navigation Graph"
    ]
  },
  {
    "id": 76,
    "question": "Which component is lifecycle-aware and cancels coroutines when the lifecycle is destroyed?",
    "answer": "lifecycleScope",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "GlobalScope",
      "viewModelScope",
      "lifecycleScope",
      "runBlocking",
      "CoroutineScope"
    ]
  },
  {
    "id": 77,
    "question": "Which Jetpack component is recommended for background work that must survive app restarts?",
    "answer": "WorkManager",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Service",
      "IntentService",
      "WorkManager",
      "Thread",
      "CoroutineScope"
    ]
  },
  {
    "id": 78,
    "question": "Which annotation is used to provide a dependency in Hilt?",
    "answer": "@Provides",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Provides",
      "@Inject",
      "@Module",
      "@Singleton",
      "@Component"
    ]
  },
  {
    "id": 79,
    "question": "Which component provides a single source of truth for app data?",
    "answer": "Repository",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "ViewModel",
      "LiveData",
      "Repository",
      "Service",
      "DataStore"
    ]
  },
  {
    "id": 80,
    "question": "Which Jetpack library is used to observe and manage lifecycle-aware components in UI?",
    "answer": "Lifecycle",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Navigation",
      "Paging",
      "Lifecycle",
      "DataStore",
      "WorkManager"
    ]
  },
  {
    "id": 81,
    "question": "Which class provides a reactive, read-only state for UI in Jetpack?",
    "answer": "StateFlow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LiveData",
      "StateFlow",
      "SharedFlow",
      "Flow",
      "MutableStateFlow"
    ]
  },
  {
    "id": 82,
    "question": "Which Jetpack component allows scheduling one-time or periodic background tasks easily?",
    "answer": "WorkManager",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Handler",
      "Service",
      "WorkManager",
      "BroadcastReceiver",
      "ThreadPoolExecutor"
    ]
  },
  {
    "id": 83,
    "question": "Which annotation is used in Room to define SQL queries in a DAO?",
    "answer": "@Query",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Query",
      "@Insert",
      "@Update",
      "@Delete",
      "@Dao"
    ]
  },
  {
    "id": 84,
    "question": "Which Jetpack component handles safe and efficient pagination of data?",
    "answer": "Paging",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "DataStore",
      "Paging",
      "Room",
      "WorkManager",
      "LiveData"
    ]
  },
  {
    "id": 85,
    "question": "Which component allows storing simple key-value pairs asynchronously?",
    "answer": "DataStore",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "SharedPreferences",
      "Room",
      "DataStore",
      "SQLiteDatabase",
      "Repository"
    ]
  },
  {
    "id": 86,
    "question": "Which Jetpack component observes lifecycle changes and performs actions accordingly?",
    "answer": "LifecycleObserver",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LifecycleOwner",
      "ViewModel",
      "LifecycleObserver",
      "LiveData",
      "Service"
    ]
  },
  {
    "id": 87,
    "question": "Which method in ViewModel allows launching coroutines tied to ViewModel lifecycle?",
    "answer": "viewModelScope.launch { ... }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "GlobalScope.launch { ... }",
      "lifecycleScope.launch { ... }",
      "viewModelScope.launch { ... }",
      "runBlocking { ... }",
      "CoroutineScope.launch { ... }"
    ]
  },
  {
    "id": 88,
    "question": "Which Jetpack component provides reactive updates to UI when database changes?",
    "answer": "Flow from Room DAO",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LiveData",
      "Flow from Room DAO",
      "PagingSource",
      "Repository",
      "ViewModel"
    ]
  },
  {
    "id": 89,
    "question": "Which annotation is used to mark a Hilt component interface?",
    "answer": "@Component",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Inject",
      "@Module",
      "@Provides",
      "@Singleton",
      "@Component"
    ]
  },
  {
    "id": 90,
    "question": "Which Jetpack library allows observing changes to a data stream in UI?",
    "answer": "LiveData or StateFlow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Flow only",
      "LiveData or StateFlow",
      "Repository only",
      "DataStore only",
      "Paging only"
    ]
  },
  {
    "id": 91,
    "question": "Which Jetpack component is responsible for handling arguments passed to a Fragment safely?",
    "answer": "Safe Args",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Bundle",
      "Intent",
      "Safe Args",
      "SharedPreferences",
      "ViewModel"
    ]
  },
  {
    "id": 92,
    "question": "Which Jetpack library allows type-safe navigation using NavController?",
    "answer": "Navigation Component",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Navigation Component",
      "LiveData",
      "ViewModel",
      "WorkManager",
      "DataStore"
    ]
  },
  {
    "id": 93,
    "question": "Which component is recommended for handling periodic background tasks that must survive process death?",
    "answer": "WorkManager",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Handler",
      "Service",
      "WorkManager",
      "AlarmManager",
      "CoroutineScope"
    ]
  },
  {
    "id": 94,
    "question": "Which class in Jetpack stores reactive state for UI that can be collected using collectAsState() in Compose?",
    "answer": "StateFlow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LiveData",
      "StateFlow",
      "SharedFlow",
      "MutableState",
      "Flow"
    ]
  },
  {
    "id": 95,
    "question": "Which annotation in Hilt marks a constructor to be injected?",
    "answer": "@Inject",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Provides",
      "@Inject",
      "@Module",
      "@Singleton",
      "@Component"
    ]
  },
  {
    "id": 96,
    "question": "Which component is recommended as a single source of truth for app data?",
    "answer": "Repository",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "ViewModel",
      "Repository",
      "LiveData",
      "Service",
      "DataStore"
    ]
  },
  {
    "id": 97,
    "question": "Which annotation in Hilt defines reusable provider functions?",
    "answer": "@Provides",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Module",
      "@Provides",
      "@Singleton",
      "@Inject",
      "@Component"
    ]
  },
  {
    "id": 98,
    "question": "Which Jetpack component cancels coroutines automatically when the lifecycle is destroyed?",
    "answer": "lifecycleScope",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "viewModelScope",
      "lifecycleScope",
      "GlobalScope",
      "runBlocking",
      "CoroutineScope"
    ]
  },
  {
    "id": 99,
    "question": "Which annotation defines a database entity in Room?",
    "answer": "@Entity",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Entity",
      "@Database",
      "@Dao",
      "@Module",
      "@Provides"
    ]
  },
  {
    "id": 100,
    "question": "Which annotation defines a DAO in Room?",
    "answer": "@Dao",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Dao",
      "@Entity",
      "@Database",
      "@Repository",
      "@Inject"
    ]
  },
  {
    "id": 101,
    "question": "Which Compose layout arranges its children vertically?",
    "answer": "Column",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Row",
      "Column",
      "Box",
      "LazyColumn",
      "ConstraintLayout"
    ]
  },
  {
    "id": 102,
    "question": "Which Compose layout arranges its children horizontally?",
    "answer": "Row",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Row",
      "Column",
      "Box",
      "LazyRow",
      "ConstraintLayout"
    ]
  },
  {
    "id": 103,
    "question": "Which Compose layout allows stacking children on top of each other?",
    "answer": "Box",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Column",
      "Row",
      "Box",
      "LazyColumn",
      "Stack"
    ]
  },
  {
    "id": 104,
    "question": "Which Compose layout efficiently displays a vertically scrolling list?",
    "answer": "LazyColumn",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Column",
      "Row",
      "LazyColumn",
      "Box",
      "ScrollView"
    ]
  },
  {
    "id": 105,
    "question": "Which Compose layout efficiently displays a horizontally scrolling list?",
    "answer": "LazyRow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Row",
      "LazyRow",
      "Column",
      "Box",
      "ScrollView"
    ]
  },
  {
    "id": 106,
    "question": "Which function allows remembering a state across recompositions?",
    "answer": "remember",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "mutableStateOf",
      "remember",
      "derivedStateOf",
      "rememberCoroutineScope",
      "stateOf"
    ]
  },
  {
    "id": 107,
    "question": "Which function creates a mutable state in Compose?",
    "answer": "mutableStateOf",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "mutableStateOf",
      "remember",
      "stateFlowOf",
      "collectAsState",
      "derivedStateOf"
    ]
  },
  {
    "id": 108,
    "question": "Which function derives a state from other states without creating recomposition loops?",
    "answer": "derivedStateOf",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "mutableStateOf",
      "remember",
      "derivedStateOf",
      "collectAsState",
      "snapshotFlow"
    ]
  },
  {
    "id": 109,
    "question": "Which function converts a Flow into Compose state?",
    "answer": "collectAsState()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "collect()",
      "collectAsState()",
      "stateFlowOf()",
      "rememberFlow()",
      "launchIn()"
    ]
  },
  {
    "id": 110,
    "question": "Which annotation allows previewing a Composable in Android Studio?",
    "answer": "@Preview",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Composable",
      "@Preview",
      "@DesignTime",
      "@ShowPreview",
      "@Render"
    ]
  },
  {
    "id": 111,
    "question": "Which Compose component provides a standard top app bar?",
    "answer": "TopAppBar",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "TopAppBar",
      "AppBar",
      "Scaffold",
      "Toolbar",
      "Surface"
    ]
  },
  {
    "id": 112,
    "question": "Which Compose component provides a structure with top bar, bottom bar, floating action button, and content slot?",
    "answer": "Scaffold",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Surface",
      "Scaffold",
      "Box",
      "Column",
      "TopAppBar"
    ]
  },
  {
    "id": 113,
    "question": "Which Compose function is used for simple animations of values?",
    "answer": "animate*AsState",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "animate*AsState",
      "rememberInfiniteTransition",
      "Animatable",
      "LaunchedEffect",
      "Transition"
    ]
  },
  {
    "id": 114,
    "question": "Which Compose function creates an infinite repeating animation?",
    "answer": "rememberInfiniteTransition",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "animate*AsState",
      "rememberInfiniteTransition",
      "Animatable",
      "updateTransition",
      "LaunchedEffect"
    ]
  },
  {
    "id": 115,
    "question": "Which Compose function allows launching side-effects that depend on specific keys?",
    "answer": "LaunchedEffect",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "SideEffect",
      "remember",
      "LaunchedEffect",
      "DisposableEffect",
      "produceState"
    ]
  },
  {
    "id": 116,
    "question": "Which Compose function is called after every successful recomposition?",
    "answer": "SideEffect",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "SideEffect",
      "LaunchedEffect",
      "DisposableEffect",
      "remember",
      "derivedStateOf"
    ]
  },
  {
    "id": 117,
    "question": "Which Compose function handles clean-up when keys change or Composable leaves composition?",
    "answer": "DisposableEffect",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "DisposableEffect",
      "LaunchedEffect",
      "SideEffect",
      "remember",
      "derivedStateOf"
    ]
  },
  {
    "id": 118,
    "question": "Which Compose function allows producing state from a suspending block?",
    "answer": "produceState",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "produceState",
      "LaunchedEffect",
      "remember",
      "mutableStateOf",
      "derivedStateOf"
    ]
  },
  {
    "id": 119,
    "question": "Which Compose principle ensures UI updates automatically when state changes?",
    "answer": "Recomposition",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "SideEffect",
      "Snapshot",
      "Recomposition",
      "Coroutine",
      "DerivedState"
    ]
  },
  {
    "id": 120,
    "question": "Which function in Compose can be used to collect a StateFlow as state for UI?",
    "answer": "collectAsState()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "collect()",
      "collectAsState()",
      "remember",
      "derivedStateOf",
      "snapshotFlow()"
    ]
  },
  {
    "id": 121,
    "question": "Which Compose modifier sets padding around a Composable?",
    "answer": "Modifier.padding()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Modifier.margin()",
      "Modifier.padding()",
      "Modifier.size()",
      "Modifier.fillMaxSize()",
      "Modifier.offset()"
    ]
  },
  {
    "id": 122,
    "question": "Which Compose modifier makes a Composable fill maximum available width?",
    "answer": "Modifier.fillMaxWidth()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Modifier.fillMaxHeight()",
      "Modifier.fillMaxSize()",
      "Modifier.fillMaxWidth()",
      "Modifier.wrapContentWidth()",
      "Modifier.wrapContentSize()"
    ]
  },
  {
    "id": 123,
    "question": "Which Compose modifier makes a Composable fill maximum available height?",
    "answer": "Modifier.fillMaxHeight()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Modifier.fillMaxHeight()",
      "Modifier.fillMaxWidth()",
      "Modifier.fillMaxSize()",
      "Modifier.wrapContentHeight()",
      "Modifier.wrapContentSize()"
    ]
  },
  {
    "id": 124,
    "question": "Which Compose modifier makes a Composable fill both width and height?",
    "answer": "Modifier.fillMaxSize()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Modifier.fillMaxWidth()",
      "Modifier.fillMaxHeight()",
      "Modifier.fillMaxSize()",
      "Modifier.wrapContentSize()",
      "Modifier.size()"
    ]
  },
  {
    "id": 125,
    "question": "Which composable is used to add space between other composables inside a layout?",
    "answer": "Spacer()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Modifier.spacing()",
      "Spacer()",
      "Modifier.offset()",
      "Margin()",
      "Modifier.gap()"
    ]
  },
  {
    "id": 126,
    "question": "Which Compose layout arranges items in a staggered scrolling vertical list?",
    "answer": "LazyVerticalStaggeredGrid",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LazyColumn",
      "LazyRow",
      "LazyVerticalGrid",
      "Column",
      "LazyVerticalStaggeredGrid"
    ]
  },
  {
    "id": 127,
    "question": "Which Compose function previews a Composable in dark theme?",
    "answer": "@Preview(uiMode = Configuration.UI_MODE_NIGHT_YES)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Preview(uiMode = Configuration.UI_MODE_NIGHT_YES)",
      "@Preview(darkTheme = true)",
      "@Preview(theme = DarkTheme)",
      "@Preview(isDark = true)",
      "@Preview(theme = Night)"
    ]
  },
  {
    "id": 128,
    "question": "Which Compose function allows defining a custom scrollable container?",
    "answer": "verticalScroll()/horizontalScroll()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "scrollable()",
      "verticalScroll()/horizontalScroll()",
      "LazyColumn",
      "BoxScroll",
      "ScrollContainer()"
    ]
  },
  {
    "id": 129,
    "question": "Which Compose function is used to observe a StateFlow in a Composable and trigger recomposition?",
    "answer": "collectAsState()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "collect()",
      "collectAsState()",
      "remember",
      "snapshotFlow()",
      "derivedStateOf"
    ]
  },
  {
    "id": 130,
    "question": "Which Compose function allows creating gesture-detectable elements like drag and tap?",
    "answer": "Modifier.pointerInput()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Modifier.gesture()",
      "Modifier.pointerInput()",
      "Modifier.clickable()",
      "Modifier.touch()",
      "Modifier.detectTap()"
    ]
  },
  {
    "id": 131,
    "question": "Which Compose function animates a color or size value based on state change?",
    "answer": "animate*AsState",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "transition()",
      "animate*AsState",
      "updateTransition()",
      "rememberInfiniteTransition",
      "Animatable"
    ]
  },
  {
    "id": 132,
    "question": "Which Compose function is used for creating animated visibility transitions?",
    "answer": "AnimatedVisibility",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "AnimatedContent",
      "AnimatedVisibility",
      "updateTransition",
      "rememberInfiniteTransition",
      "Animatable"
    ]
  },
  {
    "id": 133,
    "question": "Which Compose function creates a custom animation specification?",
    "answer": "tween(), spring(), keyframes()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "tween(), spring(), keyframes()",
      "animate()",
      "animateValue()",
      "AnimSpec()",
      "transitionSpec()"
    ]
  },
  {
    "id": 134,
    "question": "Which Compose function triggers recomposition when a state changes inside a lambda?",
    "answer": "remember { mutableStateOf() }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "remember { mutableStateOf() }",
      "mutableStateOf()",
      "derivedStateOf()",
      "collectAsState()",
      "snapshotFlow()"
    ]
  },
  {
    "id": 135,
    "question": "Which Compose layout aligns children relative to each other using constraints?",
    "answer": "ConstraintLayout",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Box",
      "Column",
      "Row",
      "ConstraintLayout",
      "Scaffold"
    ]
  },
  {
    "id": 136,
    "question": "Which Compose function allows creating a horizontally scrolling container of items with fixed spacing?",
    "answer": "LazyRow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LazyColumn",
      "LazyRow",
      "Column",
      "Row",
      "Box"
    ]
  },
  {
    "id": 137,
    "question": "Which Compose function is used for side-effects that should run on every recomposition?",
    "answer": "SideEffect",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "SideEffect",
      "LaunchedEffect",
      "DisposableEffect",
      "remember",
      "derivedStateOf"
    ]
  },
  {
    "id": 138,
    "question": "Which Compose function cancels work and cleans up when keys change?",
    "answer": "DisposableEffect",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "DisposableEffect",
      "LaunchedEffect",
      "SideEffect",
      "remember",
      "produceState"
    ]
  },
  {
    "id": 139,
    "question": "Which Compose principle ensures a composable is recomposed when the observed state changes?",
    "answer": "State-driven UI / Recomposition",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Manual refresh",
      "State-driven UI / Recomposition",
      "Coroutines",
      "SideEffects",
      "SnapshotFlow"
    ]
  },
  {
    "id": 140,
    "question": "Which Compose function can be used to animate multiple values simultaneously?",
    "answer": "updateTransition()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "animate*AsState",
      "updateTransition()",
      "rememberInfiniteTransition",
      "Animatable",
      "LaunchedEffect"
    ]
  },
  {
    "id": 141,
    "question": "Which Compose function allows converting a Flow into a state object?",
    "answer": "collectAsState()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "collect()",
      "collectAsState()",
      "rememberFlow()",
      "derivedStateOf",
      "snapshotFlow()"
    ]
  },
  {
    "id": 142,
    "question": "Which Compose function allows launching coroutines scoped to Composable lifecycle?",
    "answer": "rememberCoroutineScope()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "rememberCoroutineScope()",
      "LaunchedEffect",
      "DisposableEffect",
      "SideEffect",
      "produceState"
    ]
  },
  {
    "id": 143,
    "question": "Which Compose component is used for scrollable tabs?",
    "answer": "ScrollableTabRow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "TabRow",
      "ScrollableTabRow",
      "LazyRow",
      "Column",
      "Row"
    ]
  },
  {
    "id": 144,
    "question": "Which Compose function allows observing LiveData as state?",
    "answer": "observeAsState()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "collectAsState()",
      "observeAsState()",
      "rememberLiveData()",
      "derivedStateOf",
      "snapshotFlow()"
    ]
  },
  {
    "id": 145,
    "question": "Which Compose modifier allows applying a background color?",
    "answer": "Modifier.background()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Modifier.background()",
      "Modifier.color()",
      "Modifier.fillMaxSize()",
      "Modifier.surface()",
      "Modifier.themeColor()"
    ]
  },
  {
    "id": 146,
    "question": "Which Compose modifier adds clickable behavior to a Composable?",
    "answer": "Modifier.clickable()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Modifier.pointerInput()",
      "Modifier.clickable()",
      "Modifier.touchable()",
      "Modifier.gesture()",
      "Modifier.tap()"
    ]
  },
  {
    "id": 147,
    "question": "Which Compose modifier allows applying padding around a Composable?",
    "answer": "Modifier.padding()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Modifier.padding()",
      "Modifier.margin()",
      "Modifier.gap()",
      "Modifier.spacing()",
      "Modifier.offset()"
    ]
  },
  {
    "id": 148,
    "question": "Which Compose function provides a slot for a bottom navigation bar in Scaffold?",
    "answer": "bottomBar",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "bottomBar",
      "topBar",
      "floatingActionButton",
      "content",
      "drawerContent"
    ]
  },
  {
    "id": 149,
    "question": "Which Compose function is used to animate the placement of items in a LazyColumn?",
    "answer": "animateItemPlacement()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "animateItemPlacement()",
      "animateContentSize()",
      "animate*AsState",
      "updateTransition()",
      "Animatable"
    ]
  },
  {
    "id": 150,
    "question": "Which Compose function allows applying a custom layout modifier for positioning?",
    "answer": "layout()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "layout()",
      "Modifier.position()",
      "Modifier.offset()",
      "Modifier.align()",
      "Modifier.zIndex()"
    ]
  },
  {
    "id": 151,
    "question": "In MVVM, which component holds UI-related data and survives configuration changes?",
    "answer": "ViewModel",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Activity",
      "Fragment",
      "Repository",
      "ViewModel",
      "LiveData"
    ]
  },
  {
    "id": 152,
    "question": "Which layer in MVVM is responsible for providing data from network or database?",
    "answer": "Repository",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "ViewModel",
      "Repository",
      "UI",
      "UseCase",
      "Service"
    ]
  },
  {
    "id": 153,
    "question": "Which component in MVVM observes data changes and updates the UI automatically?",
    "answer": "LiveData / StateFlow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LiveData / StateFlow",
      "ViewModel",
      "Repository",
      "Activity",
      "Fragment"
    ]
  },
  {
    "id": 154,
    "question": "Which dependency injection library is officially supported by Android for MVVM projects?",
    "answer": "Hilt",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Dagger",
      "Hilt",
      "Koin",
      "Kodein",
      "Guice"
    ]
  },
  {
    "id": 155,
    "question": "Which annotation in Hilt marks a class for constructor injection?",
    "answer": "@Inject",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Provide",
      "@Module",
      "@Inject",
      "@Singleton",
      "@Bind"
    ]
  },
  {
    "id": 156,
    "question": "Which Hilt annotation provides a singleton instance of a dependency?",
    "answer": "@Singleton",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Singleton",
      "@Inject",
      "@Module",
      "@Provides",
      "@Scoped"
    ]
  },
  {
    "id": 157,
    "question": "Which Hilt annotation defines a module that provides dependencies?",
    "answer": "@Module",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Provides",
      "@Singleton",
      "@Module",
      "@Inject",
      "@Component"
    ]
  },
  {
    "id": 158,
    "question": "Which Hilt annotation defines a function that provides a dependency instance?",
    "answer": "@Provides",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Module",
      "@Singleton",
      "@Provides",
      "@Inject",
      "@Bind"
    ]
  },
  {
    "id": 159,
    "question": "Which pattern ensures a single source of truth for data?",
    "answer": "Repository pattern",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "MVVM",
      "MVI",
      "Repository pattern",
      "Singleton",
      "Service Locator"
    ]
  },
  {
    "id": 160,
    "question": "In MVI, what does 'Intent' represent?",
    "answer": "User actions or events",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "UI state",
      "Side-effects",
      "User actions or events",
      "Repositories",
      "ViewModel functions"
    ]
  },
  {
    "id": 161,
    "question": "In MVI, what does 'State' represent?",
    "answer": "UI representation at a given time",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Intent",
      "UI representation at a given time",
      "Actions",
      "Side-effects",
      "Repository data"
    ]
  },
  {
    "id": 162,
    "question": "In MVI, what does 'Effect' represent?",
    "answer": "One-time events like navigation or Toasts",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "UI state",
      "Repository updates",
      "One-time events like navigation or Toasts",
      "User actions",
      "ViewModel data"
    ]
  },
  {
    "id": 163,
    "question": "Which principle is core to MVVM regarding data flow?",
    "answer": "Unidirectional data flow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Bidirectional data flow",
      "Unidirectional data flow",
      "Random data flow",
      "Two-way binding only",
      "Event-driven flow"
    ]
  },
  {
    "id": 164,
    "question": "Which function is recommended to test ViewModel logic in isolation?",
    "answer": "Using JUnit and coroutine test rules",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Using Espresso",
      "Using JUnit and coroutine test rules",
      "Using ActivityScenario",
      "Using UIAutomator",
      "Manual testing"
    ]
  },
  {
    "id": 165,
    "question": "Which component in MVVM should not hold Android context?",
    "answer": "ViewModel",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Activity",
      "Fragment",
      "ViewModel",
      "Repository",
      "Service"
    ]
  },
  {
    "id": 166,
    "question": "Which testing library is commonly used for mocking dependencies in ViewModel tests?",
    "answer": "Mockito / MockK",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Espresso",
      "JUnit",
      "Mockito / MockK",
      "Robolectric",
      "Truth"
    ]
  },
  {
    "id": 167,
    "question": "Which annotation allows Hilt to inject dependencies into an Android Activity?",
    "answer": "@AndroidEntryPoint",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Inject",
      "@AndroidEntryPoint",
      "@HiltActivity",
      "@Provide",
      "@Module"
    ]
  },
  {
    "id": 168,
    "question": "Which scope is commonly used for dependencies that should live as long as the application?",
    "answer": "Singleton / Application scope",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Activity scope",
      "Fragment scope",
      "Singleton / Application scope",
      "ViewModel scope",
      "Session scope"
    ]
  },
  {
    "id": 169,
    "question": "Which function allows injecting dependencies into a Fragment with Hilt?",
    "answer": "@AndroidEntryPoint annotated Fragment",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Fragment.inject()",
      "HiltFragment()",
      "@AndroidEntryPoint annotated Fragment",
      "@InjectFragment",
      "FragmentComponent.inject()"
    ]
  },
  {
    "id": 170,
    "question": "Which principle recommends that repositories provide data as Flow or LiveData?",
    "answer": "Reactive programming / Observables",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Imperative programming",
      "Reactive programming / Observables",
      "Synchronous calls",
      "Callback hell",
      "Singleton pattern"
    ]
  },
  {
    "id": 171,
    "question": "Which testing technique verifies that repository functions return expected results?",
    "answer": "Unit testing",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Unit testing",
      "UI testing",
      "Integration testing",
      "Instrumentation testing",
      "Snapshot testing"
    ]
  },
  {
    "id": 172,
    "question": "Which annotation can be used to mark a Hilt module installed in SingletonComponent?",
    "answer": "@InstallIn(SingletonComponent::class)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@InstallIn(SingletonComponent::class)",
      "@Module",
      "@Singleton",
      "@Provides",
      "@EntryPoint"
    ]
  },
  {
    "id": 173,
    "question": "Which approach is recommended to keep ViewModel logic testable?",
    "answer": "No Android framework dependencies",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Use Context inside ViewModel",
      "No Android framework dependencies",
      "Direct UI references",
      "Access Resources directly",
      "Use Activity inside ViewModel"
    ]
  },
  {
    "id": 174,
    "question": "Which principle suggests that data should flow in one direction from Repository -> ViewModel -> UI?",
    "answer": "Unidirectional data flow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Bidirectional binding",
      "Unidirectional data flow",
      "Two-way binding only",
      "Event-driven",
      "Reactive streams only"
    ]
  },
  {
    "id": 175,
    "question": "Which Hilt component scope is tied to a ViewModel's lifecycle?",
    "answer": "ViewModelComponent",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "ActivityComponent",
      "FragmentComponent",
      "ViewModelComponent",
      "SingletonComponent",
      "ServiceComponent"
    ]
  },
  {
    "id": 176,
    "question": "Which test library allows asserting LiveData values?",
    "answer": "Turbine / LiveData Test Observer",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Espresso",
      "Turbine / LiveData Test Observer",
      "Mockito",
      "JUnit",
      "UIAutomator"
    ]
  },
  {
    "id": 177,
    "question": "Which Hilt annotation allows injecting a dependency into a constructor?",
    "answer": "@Inject",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Module",
      "@Provides",
      "@Singleton",
      "@Inject",
      "@EntryPoint"
    ]
  },
  {
    "id": 178,
    "question": "Which pattern is used to isolate data sources behind a single interface?",
    "answer": "Repository pattern",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "MVVM",
      "Repository pattern",
      "MVI",
      "Singleton",
      "Service Locator"
    ]
  },
  {
    "id": 179,
    "question": "Which testing principle ensures ViewModel logic can run synchronously in tests?",
    "answer": "Use runTest or TestCoroutineDispatcher",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Use Espresso",
      "Use runTest or TestCoroutineDispatcher",
      "Use ActivityScenario",
      "Use Mockito only",
      "Use Thread.sleep()"
    ]
  },
  {
    "id": 180,
    "question": "Which MVI component transforms Intent into State?",
    "answer": "Reducer",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "IntentHandler",
      "Reducer",
      "Repository",
      "ViewModel",
      "StateObserver"
    ]
  },
  {
    "id": 181,
    "question": "Which testing strategy is used to test multiple repository layers together?",
    "answer": "Integration testing",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Unit testing",
      "Integration testing",
      "UI testing",
      "Snapshot testing",
      "End-to-end testing"
    ]
  },
  {
    "id": 182,
    "question": "Which component in MVVM holds references to multiple repositories?",
    "answer": "ViewModel",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Activity",
      "Fragment",
      "ViewModel",
      "Repository",
      "Service"
    ]
  },
  {
    "id": 183,
    "question": "Which Hilt annotation allows defining bindings without exposing a module class?",
    "answer": "@Binds",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Provides",
      "@Binds",
      "@Module",
      "@Inject",
      "@Singleton"
    ]
  },
  {
    "id": 184,
    "question": "Which principle helps keeping Android app modular and testable?",
    "answer": "Separation of concerns",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Singleton pattern",
      "Separation of concerns",
      "Event-driven",
      "Observer pattern",
      "Direct coupling"
    ]
  },
  {
    "id": 185,
    "question": "Which component is responsible for mapping network responses to domain models?",
    "answer": "Repository",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "ViewModel",
      "Repository",
      "Activity",
      "UseCase",
      "UI layer"
    ]
  },
  {
    "id": 186,
    "question": "Which Hilt scope should be used for dependencies tied to Activity lifecycle?",
    "answer": "ActivityComponent",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "FragmentComponent",
      "ActivityComponent",
      "ViewModelComponent",
      "SingletonComponent",
      "ServiceComponent"
    ]
  },
  {
    "id": 187,
    "question": "What annotation should mark the ViewModel class with so that Hilt can provide its dependencies?",
    "answer": "@HiltViewModel",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Inject",
      "@HiltViewModel",
      "@Module",
      "@AndroidEntryPoint",
      "@Provides"
    ]
  },
  {
    "id": 188,
    "question": "Which design principle recommends that each layer has only one responsibility?",
    "answer": "Single Responsibility Principle (SRP)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Open/Closed Principle",
      "Dependency Inversion",
      "Single Responsibility Principle (SRP)",
      "Liskov Substitution",
      "Interface Segregation"
    ]
  },
  {
    "id": 189,
    "question": "Which tool helps testing coroutine flows in ViewModel?",
    "answer": "Turbine",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Espresso",
      "JUnit",
      "Turbine",
      "Mockito",
      "UIAutomator"
    ]
  },
  {
    "id": 190,
    "question": "Which MVI component holds the immutable UI state?",
    "answer": "State",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Intent",
      "Reducer",
      "State",
      "Effect",
      "ViewModel"
    ]
  },
  {
    "id": 191,
    "question": "Which Hilt annotation allows scoping a module to a specific Android component?",
    "answer": "@InstallIn",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@InstallIn",
      "@Module",
      "@Provides",
      "@Singleton",
      "@Binds"
    ]
  },
  {
    "id": 192,
    "question": "Which principle ensures repositories provide one source of truth and decoupled UI?",
    "answer": "Single Source of Truth",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "MVVM",
      "Unidirectional Flow",
      "Single Source of Truth",
      "Dependency Injection",
      "MVI"
    ]
  },
  {
    "id": 193,
    "question": "Which Hilt annotation allows providing multiple implementations of an interface?",
    "answer": "@Binds / @Qualifier",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Provides",
      "@Binds / @Qualifier",
      "@Singleton",
      "@Module",
      "@Inject"
    ]
  },
  {
    "id": 194,
    "question": "Which testing type verifies UI and ViewModel interactions together?",
    "answer": "Instrumented / UI tests",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Unit testing",
      "Integration testing",
      "Instrumented / UI tests",
      "Snapshot tests",
      "End-to-end tests"
    ]
  },
  {
    "id": 195,
    "question": "Which MVI component handles side-effects like navigation or Toasts?",
    "answer": "Effect",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "State",
      "Reducer",
      "Effect",
      "Intent",
      "Repository"
    ]
  },
  {
    "id": 196,
    "question": "Which Hilt component handles dependencies tied to Fragment lifecycle?",
    "answer": "FragmentComponent",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "ActivityComponent",
      "ViewModelComponent",
      "FragmentComponent",
      "SingletonComponent",
      "ServiceComponent"
    ]
  },
  {
    "id": 197,
    "question": "Which ViewModel testing principle avoids using Android framework dependencies?",
    "answer": "Keep ViewModel pure and platform-independent",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Use Activity references",
      "Keep ViewModel pure and platform-independent",
      "Access Resources",
      "Use Context",
      "Use LiveData only"
    ]
  },
  {
    "id": 198,
    "question": "Which principle suggests that changes in state should trigger UI updates automatically?",
    "answer": "Reactive / Observables",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Imperative",
      "Reactive / Observables",
      "Manual refresh",
      "Polling",
      "Thread.sleep()"
    ]
  },
  {
    "id": 199,
    "question": "Which Hilt scope is tied to the lifetime of the Application?",
    "answer": "SingletonComponent",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "ViewModelComponent",
      "ActivityComponent",
      "FragmentComponent",
      "SingletonComponent",
      "ServiceComponent"
    ]
  },
  {
    "id": 200,
    "question": "Which pattern ensures clear separation between UI, business logic, and data sources?",
    "answer": "MVVM",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "MVI",
      "MVVM",
      "MVP",
      "Singleton",
      "Repository pattern"
    ]
  },
  {
    "id": 201,
    "question": "Which annotation marks a Kotlin data class as a Room database entity?",
    "answer": "@Entity",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Table",
      "@Entity",
      "@DataClass",
      "@Database",
      "@Dao"
    ]
  },
  {
    "id": 202,
    "question": "Which annotation marks a DAO interface in Room?",
    "answer": "@Dao",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Dao",
      "@Repository",
      "@Database",
      "@Entity",
      "@Inject"
    ]
  },
  {
    "id": 203,
    "question": "Which annotation defines the Room database class?",
    "answer": "@Database",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Database",
      "@Entity",
      "@Dao",
      "@RoomDB",
      "@Module"
    ]
  },
  {
    "id": 204,
    "question": "Which annotation is used to write SQL select queries in Room DAO?",
    "answer": "@Query",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Insert",
      "@Select",
      "@Query",
      "@Update",
      "@Delete"
    ]
  },
  {
    "id": 205,
    "question": "Which annotation is used to insert data in Room?",
    "answer": "@Insert",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Query",
      "@Update",
      "@Insert",
      "@Delete",
      "@Put"
    ]
  },
  {
    "id": 206,
    "question": "Which annotation is used to update data in Room?",
    "answer": "@Update",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Query",
      "@Update",
      "@Insert",
      "@Delete",
      "@Patch"
    ]
  },
  {
    "id": 207,
    "question": "Which annotation is used to delete data in Room?",
    "answer": "@Delete",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Delete",
      "@Remove",
      "@Update",
      "@Query",
      "@Insert"
    ]
  },
  {
    "id": 208,
    "question": "Which function type allows observing Room database changes reactively?",
    "answer": "Flow / LiveData",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Flow / LiveData",
      "List",
      "ObservableField",
      "StateFlow",
      "MutableMap"
    ]
  },
  {
    "id": 209,
    "question": "Which annotation allows defining a primary key in Room?",
    "answer": "@PrimaryKey",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Key",
      "@Primary",
      "@PrimaryKey",
      "@Id",
      "@Unique"
    ]
  },
  {
    "id": 210,
    "question": "How do you auto-generate a primary key in Room?",
    "answer": "@PrimaryKey(autoGenerate = true)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@PrimaryKey",
      "@PrimaryKey(autoGenerate = true)",
      "@AutoKey",
      "@Id(autoGenerate = true)",
      "@Generated"
    ]
  },
  {
    "id": 211,
    "question": "Which annotation allows indexing a column in Room for faster queries?",
    "answer": "@Index",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Index",
      "@ColumnIndex",
      "@Indexed",
      "@ForeignKey",
      "@QueryIndex"
    ]
  },
  {
    "id": 212,
    "question": "Which annotation defines a foreign key in Room?",
    "answer": "@ForeignKey",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Relation",
      "@ForeignKey",
      "@Reference",
      "@ParentKey",
      "@ChildKey"
    ]
  },
  {
    "id": 213,
    "question": "Which annotation is used to define a one-to-many relationship in Room?",
    "answer": "@Relation",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@OneToMany",
      "@ForeignKey",
      "@Relation",
      "@Embedded",
      "@JoinColumn"
    ]
  },
  {
    "id": 214,
    "question": "Which annotation embeds one data class into another in Room?",
    "answer": "@Embedded",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Embedded",
      "@Relation",
      "@Include",
      "@Compose",
      "@Nested"
    ]
  },
  {
    "id": 215,
    "question": "Which annotation allows defining database migrations in Room?",
    "answer": "@Database(version = X, exportSchema = true)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Migration",
      "@Database(version = X, exportSchema = true)",
      "@UpdateSchema",
      "@DbVersion",
      "@SchemaMigration"
    ]
  },
  {
    "id": 216,
    "question": "Which type of query can return a Flow to observe changes automatically?",
    "answer": "Flow<List<Entity>>",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "List<Entity>",
      "LiveData<Entity>",
      "Flow<List<Entity>>",
      "Entity",
      "Observable<List<Entity>>"
    ]
  },
  {
    "id": 217,
    "question": "Which annotation can mark a column as non-null in Room?",
    "answer": "@NonNull",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@NotNull",
      "@NonNull",
      "@Nullable",
      "@PrimaryKey",
      "@Required"
    ]
  },
  {
    "id": 218,
    "question": "Which annotation allows defining a default value for a Room column?",
    "answer": "defaultValue in @ColumnInfo",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Default",
      "defaultValue in @ColumnInfo",
      "@ColumnDefault",
      "@InitialValue",
      "@DefaultValue"
    ]
  },
  {
    "id": 219,
    "question": "Which function is used to run multiple database operations atomically in Room?",
    "answer": "@Transaction",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Atomic",
      "@Transaction",
      "@Synchronized",
      "@Batch",
      "@AllOrNothing"
    ]
  },
  {
    "id": 220,
    "question": "Which type is recommended for storing large binary data in Room?",
    "answer": "ByteArray",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Blob",
      "ByteArray",
      "String",
      "IntArray",
      "Bitmap"
    ]
  },
  {
    "id": 221,
    "question": "Which annotation allows ignoring a field from being persisted in Room?",
    "answer": "@Ignore",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Transient",
      "@Ignore",
      "@Exclude",
      "@NotPersisted",
      "@Skip"
    ]
  },
  {
    "id": 222,
    "question": "Which annotation allows setting a custom column name in Room?",
    "answer": "@ColumnInfo(name = \"custom_name\")",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Column(name = \"custom_name\")",
      "@ColumnInfo(name = \"custom_name\")",
      "@CustomColumn(\"custom_name\")",
      "@FieldName(\"custom_name\")",
      "@ColumnAlias(\"custom_name\")"
    ]
  },
  {
    "id": 223,
    "question": "Which type should you use in Room for reactive streams?",
    "answer": "Flow",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LiveData",
      "Flow",
      "ObservableField",
      "StateFlow",
      "List"
    ]
  },
  {
    "id": 224,
    "question": "Which annotation allows embedding multiple objects as columns in a Room entity?",
    "answer": "@Embedded",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Embedded",
      "@Relation",
      "@Include",
      "@ColumnInfo",
      "@Nested"
    ]
  },
  {
    "id": 225,
    "question": "Which method allows running Room queries on a background thread?",
    "answer": "suspend functions / coroutines",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "AsyncTask",
      "Threads",
      "suspend functions / coroutines",
      "runBlocking",
      "ExecutorService"
    ]
  },
  {
    "id": 226,
    "question": "Which annotation can mark a DAO method as a suspend function?",
    "answer": "suspend",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Suspend",
      "suspend",
      "@Async",
      "@Background",
      "@Coroutine"
    ]
  },
  {
    "id": 227,
    "question": "Which type is recommended for a primary key that is auto-generated?",
    "answer": "Int / Long",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "String",
      "UUID",
      "Int / Long",
      "Boolean",
      "Double"
    ]
  },
  {
    "id": 228,
    "question": "Which annotation allows Room to handle database versioning?",
    "answer": "@Database(version = X)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Version",
      "@SchemaVersion",
      "@Database(version = X)",
      "@Migration",
      "@DbVersion"
    ]
  },
  {
    "id": 229,
    "question": "Which annotation can be used to create a composite primary key?",
    "answer": "primaryKeys in @Entity",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@PrimaryKey(composite = true)",
      "primaryKeys in @Entity",
      "@CompositeKey",
      "@MultiKey",
      "@KeySet"
    ]
  },
  {
    "id": 230,
    "question": "Which annotation allows creating indexes on multiple columns in Room?",
    "answer": "indices in @Entity",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Index(columns = ...)",
      "indices in @Entity",
      "@IndexedColumns",
      "@ColumnIndex",
      "@MultiIndex"
    ]
  },
  {
    "id": 231,
    "question": "Which annotation allows defining a one-to-one relationship in Room?",
    "answer": "@Relation",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@OneToOne",
      "@Relation",
      "@Embedded",
      "@ForeignKey",
      "@JoinColumn"
    ]
  },
  {
    "id": 232,
    "question": "Which annotation allows defining a many-to-many relationship in Room?",
    "answer": "Use two @Relation with junction entity",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@ManyToMany",
      "Use two @Relation with junction entity",
      "@Relation(manyToMany = true)",
      "@ForeignKey(manyToMany = true)",
      "@Embedded(manyToMany = true)"
    ]
  },
  {
    "id": 233,
    "question": "Which function allows observing database changes using LiveData?",
    "answer": "fun getAll(): LiveData<List<Entity>>",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "fun getAll(): List<Entity>",
      "fun getAll(): Flow<List<Entity>>",
      "fun getAll(): LiveData<List<Entity>>",
      "fun getAll(): Observable<List<Entity>>",
      "fun getAll(): StateFlow<List<Entity>>"
    ]
  },
  {
    "id": 234,
    "question": "Which Room DAO method signature allows deletion by entity?",
    "answer": "@Delete fun delete(entity: Entity)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Delete fun delete(entity: Entity)",
      "@Query(\"DELETE FROM table\") fun delete(entity: Entity)",
      "@Remove fun delete(entity: Entity)",
      "fun delete(entity: Entity)",
      "@Delete fun deleteById(id: Int)"
    ]
  },
  {
    "id": 235,
    "question": "Which Room DAO method allows updating multiple entities at once?",
    "answer": "@Update fun update(vararg entities: Entity)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Update fun update(vararg entities: Entity)",
      "@Update fun update(entities: List<Entity>)",
      "@Update fun updateAll(entities: Entity)",
      "@Query fun updateAll(entities: Entity)",
      "@Update fun update(entity: Entity)"
    ]
  },
  {
    "id": 236,
    "question": "Which annotation allows Room to ignore a field in a data class?",
    "answer": "@Ignore",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Transient",
      "@Ignore",
      "@NotPersisted",
      "@Exclude",
      "@Skip"
    ]
  },
  {
    "id": 237,
    "question": "Which Room annotation allows defining the database version number?",
    "answer": "version in @Database",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "version in @Database",
      "@Version",
      "@SchemaVersion",
      "@DbVersion",
      "@Migration"
    ]
  },
  {
    "id": 238,
    "question": "Which type is recommended for storing JSON strings in Room?",
    "answer": "String",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Blob",
      "ByteArray",
      "String",
      "Text",
      "JsonObject"
    ]
  },
  {
    "id": 239,
    "question": "Which annotation allows embedding multiple fields from another data class?",
    "answer": "@Embedded",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Embedded",
      "@Include",
      "@Compose",
      "@Nested",
      "@Relation"
    ]
  },
  {
    "id": 240,
    "question": "Which function allows executing database operations on the main thread (not recommended)?",
    "answer": "allowMainThreadQueries()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "runOnMainThread()",
      "allowMainThreadQueries()",
      "mainThreadQuery()",
      "executeMainThread()",
      "runBlockingMain()"
    ]
  },
  {
    "id": 241,
    "question": "Which annotation can mark an entity's field as unique?",
    "answer": "@ColumnInfo(unique = true)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Unique",
      "@ColumnInfo(unique = true)",
      "@ColumnUnique",
      "@UniqueKey",
      "@PrimaryKey(unique=true)"
    ]
  },
  {
    "id": 242,
    "question": "Which function allows retrieving a single entity by primary key?",
    "answer": "@Query(\"SELECT * FROM table WHERE id = :id\") fun getById(id: Int): Entity",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "fun getById(id: Int): Entity",
      "@Query(\"SELECT * FROM table WHERE id = :id\") fun getById(id: Int): Entity",
      "@Select(id) fun getById(id: Int): Entity",
      "@FindById fun getById(id: Int): Entity",
      "@QueryById fun getById(id: Int): Entity"
    ]
  },
  {
    "id": 243,
    "question": "Which function allows observing a single entity reactively with Flow?",
    "answer": "fun getById(id: Int): Flow<Entity>",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "fun getById(id: Int): Entity",
      "fun getById(id: Int): LiveData<Entity>",
      "fun getById(id: Int): Flow<Entity>",
      "fun getById(id: Int): StateFlow<Entity>",
      "fun getById(id: Int): Observable<Entity>"
    ]
  },
  {
    "id": 244,
    "question": "Which annotation allows setting a default value for a column in Room?",
    "answer": "defaultValue in @ColumnInfo",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Default",
      "defaultValue in @ColumnInfo",
      "@ColumnDefault",
      "@InitialValue",
      "@DefaultValue"
    ]
  },
  {
    "id": 245,
    "question": "Which annotation allows defining a composite index on multiple columns?",
    "answer": "indices in @Entity",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Index(columns = ...)",
      "indices in @Entity",
      "@CompositeIndex",
      "@MultiIndex",
      "@ColumnIndex"
    ]
  },
  {
    "id": 246,
    "question": "Which Room DAO method signature allows deleting multiple entities?",
    "answer": "@Delete fun delete(vararg entities: Entity)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Delete fun delete(vararg entities: Entity)",
      "@Delete fun delete(entities: List<Entity>)",
      "@Query(\"DELETE FROM table\") fun deleteAll()",
      "@Delete fun deleteAll(entities: Entity)",
      "fun deleteAll(entities: List<Entity>)"
    ]
  },
  {
    "id": 247,
    "question": "Which type should you use for storing timestamps in Room?",
    "answer": "Long",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Date",
      "String",
      "Long",
      "Instant",
      "Calendar"
    ]
  },
  {
    "id": 248,
    "question": "How do you define a column as nullable in Room?",
    "answer": "Use a nullable type (e.g., String?)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Use a nullable type (e.g., String?)",
      "@Nullable",
      "@NotNull",
      "@ColumnNullable",
      "allowNull = true"
    ]
  },
  {
    "id": 249,
    "question": "Which function allows performing database migrations in Room?",
    "answer": "addMigrations(Migration(...))",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "addMigrations(Migration(...))",
      "updateSchema()",
      "migrateTo(version)",
      "runMigration()",
      "applyMigration()"
    ]
  },
  {
    "id": 250,
    "question": "Which annotation can mark a field to be ignored in database queries but still available in entity?",
    "answer": "@Ignore",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Transient",
      "@Ignore",
      "@Exclude",
      "@NotPersisted",
      "@Skip"
    ]
  },
  {
    "id": 251,
    "question": "Which library is used for type-safe HTTP networking in Android?",
    "answer": "Retrofit",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "OkHttp",
      "Volley",
      "Retrofit",
      "HttpClient",
      "Fuel"
    ]
  },
  {
    "id": 252,
    "question": "Which class in OkHttp is used to make HTTP requests?",
    "answer": "OkHttpClient",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "HttpClient",
      "OkHttpClient",
      "RequestBuilder",
      "HttpConnection",
      "RequestManager"
    ]
  },
  {
    "id": 253,
    "question": "Which annotation in Retrofit specifies the HTTP GET method?",
    "answer": "@GET",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@GET",
      "@POST",
      "@PUT",
      "@HTTPGET",
      "@Fetch"
    ]
  },
  {
    "id": 254,
    "question": "Which annotation in Retrofit is used for query parameters?",
    "answer": "@Query",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Param",
      "@Query",
      "@Field",
      "@Body",
      "@RequestParam"
    ]
  },
  {
    "id": 255,
    "question": "Which annotation in Retrofit is used for request body?",
    "answer": "@Body",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Body",
      "@Field",
      "@Query",
      "@RequestBody",
      "@Form"
    ]
  },
  {
    "id": 256,
    "question": "Which function in OkHttp is used to execute a request synchronously?",
    "answer": "Call.execute()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Call.run()",
      "Call.execute()",
      "Call.start()",
      "Call.enqueue()",
      "Call.request()"
    ]
  },
  {
    "id": 257,
    "question": "Which function in OkHttp executes a request asynchronously?",
    "answer": "Call.enqueue()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Call.executeAsync()",
      "Call.enqueue()",
      "Call.runAsync()",
      "Call.start()",
      "Call.launch()"
    ]
  },
  {
    "id": 258,
    "question": "Which library is commonly used for JSON serialization in Retrofit?",
    "answer": "Gson",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Moshi",
      "Jackson",
      "Gson",
      "Kotlinx.serialization",
      "FastJson"
    ]
  },
  {
    "id": 259,
    "question": "Which annotation specifies the base URL in Retrofit?",
    "answer": "baseUrl() in Retrofit.Builder",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "baseUrl() in Retrofit.Builder",
      "@BaseUrl",
      "@Url",
      "setBaseUrl()",
      "@Endpoint"
    ]
  },
  {
    "id": 260,
    "question": "Which function in Retrofit interface can be marked suspend for coroutines?",
    "answer": "suspend fun getData(): Response<Type>",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "fun getData(): Response<Type>",
      "suspend fun getData(): Response<Type>",
      "fun getDataAsync(): Response<Type>",
      "fun getData(): Deferred<Type>",
      "fun getData(): Call<Type>"
    ]
  },
  {
    "id": 261,
    "question": "Which Kotlin type is typically used to observe the results of a Retrofit network call in a reactive way?",
    "answer": "Flow<Response<Type>>",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LiveData<Response<Type>>",
      "Flow<Response<Type>>",
      "Deferred<Response<Type>>",
      "Observable<Response<Type>>",
      "Call<Response<Type>>"
    ]
  },
  {
    "id": 262,
    "question": "Which OkHttp interceptor can modify requests before sending?",
    "answer": "Interceptor",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Interceptor",
      "Callback",
      "RequestFilter",
      "Authenticator",
      "Handler"
    ]
  },
  {
    "id": 263,
    "question": "Which OkHttp class is used for adding logging of HTTP requests/responses?",
    "answer": "HttpLoggingInterceptor",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "LoggingClient",
      "HttpLogger",
      "HttpLoggingInterceptor",
      "InterceptorLogger",
      "RequestLogger"
    ]
  },
  {
    "id": 264,
    "question": "Which exception indicates network failure in Retrofit?",
    "answer": "IOException",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "HttpException",
      "IOException",
      "NetworkError",
      "SocketException",
      "TimeoutException"
    ]
  },
  {
    "id": 265,
    "question": "Which Retrofit exception indicates non-2xx HTTP response?",
    "answer": "HttpException",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "IOException",
      "HttpException",
      "NetworkException",
      "ResponseError",
      "ApiException"
    ]
  },
  {
    "id": 266,
    "question": "Which Retrofit call adapter allows using Kotlin coroutines?",
    "answer": "kotlinx-coroutines CallAdapter",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "RxJava2 CallAdapter",
      "kotlinx-coroutines CallAdapter",
      "LiveData CallAdapter",
      "Observable CallAdapter",
      "Deferred CallAdapter"
    ]
  },
  {
    "id": 267,
    "question": "Which Retrofit converter is used to parse JSON using Moshi?",
    "answer": "MoshiConverterFactory",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "GsonConverterFactory",
      "MoshiConverterFactory",
      "JacksonConverterFactory",
      "KotlinxConverterFactory",
      "JsonConverter"
    ]
  },
  {
    "id": 268,
    "question": "Which operator in Kotlin Flow handles errors gracefully?",
    "answer": "catch",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "onError",
      "catch",
      "handleError",
      "tryCatch",
      "recover"
    ]
  },
  {
    "id": 269,
    "question": "Which operator in Flow emits elements on a specified dispatcher?",
    "answer": "flowOn",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "flowOn",
      "onDispatcher",
      "launchOn",
      "dispatchOn",
      "emitOn"
    ]
  },
  {
    "id": 270,
    "question": "Which operator in Flow transforms elements asynchronously?",
    "answer": "flatMapMerge",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "map",
      "flatMap",
      "flatMapMerge",
      "collect",
      "filter"
    ]
  },
  {
    "id": 271,
    "question": "Which function starts collecting a Flow?",
    "answer": "collect",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "collect",
      "launch",
      "subscribe",
      "flowCollect",
      "observe"
    ]
  },
  {
    "id": 272,
    "question": "Which function launches a coroutine in ViewModel scope?",
    "answer": "viewModelScope.launch { ... }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "GlobalScope.launch { ... }",
      "viewModelScope.launch { ... }",
      "lifecycleScope.launch { ... }",
      "CoroutineScope.launch { ... }",
      "MainScope.launch { ... }"
    ]
  },
  {
    "id": 273,
    "question": "Which function allows retrying failed network requests in Flow?",
    "answer": "retry",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "repeat",
      "retry",
      "catch",
      "onError",
      "recover"
    ]
  },
  {
    "id": 274,
    "question": "Which Retrofit annotation sends a form-encoded POST request?",
    "answer": "@FormUrlEncoded with @POST",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@FormUrlEncoded with @POST",
      "@FormEncoded",
      "@Body",
      "@PostForm",
      "@POST with form()"
    ]
  },
  {
    "id": 275,
    "question": "Which annotation specifies a field in a form-encoded request?",
    "answer": "@Field",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Field",
      "@FormField",
      "@BodyField",
      "@FormParam",
      "@Param"
    ]
  },
  {
    "id": 276,
    "question": "Which operator converts a cold Flow into a hot SharedFlow?",
    "answer": "shareIn",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "shareIn",
      "stateIn",
      "publishIn",
      "hotFlow",
      "broadcastIn"
    ]
  },
  {
    "id": 277,
    "question": "Which operator exposes the current value of a StateFlow?",
    "answer": "value",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "current",
      "emit",
      "value",
      "collect",
      "getValue()"
    ]
  },
  {
    "id": 278,
    "question": "Which function allows converting a suspend function into Flow?",
    "answer": "flow { emit(suspendFunction()) }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "suspendAsFlow()",
      "flow { emit(suspendFunction()) }",
      "asFlow()",
      "toFlow()",
      "emitFlow(suspendFunction())"
    ]
  },
  {
    "id": 279,
    "question": "Which operator in Flow can limit the number of emitted items?",
    "answer": "take(n)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "limit(n)",
      "take(n)",
      "first(n)",
      "count(n)",
      "slice(n)"
    ]
  },
  {
    "id": 280,
    "question": "Which exception type is used to handle HTTP errors with Retrofit?",
    "answer": "HttpException",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "IOException",
      "HttpException",
      "NetworkException",
      "ApiError",
      "ResponseError"
    ]
  },
  {
    "id": 281,
    "question": "Which Retrofit annotation is used for dynamic URLs?",
    "answer": "@Url",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Url",
      "@DynamicUrl",
      "@GETUrl",
      "@Endpoint",
      "@Path"
    ]
  },
  {
    "id": 282,
    "question": "Which annotation is used for path parameters in Retrofit?",
    "answer": "@Path",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Param",
      "@Path",
      "@Query",
      "@Url",
      "@Body"
    ]
  },
  {
    "id": 283,
    "question": "Which OkHttp class is used to cancel ongoing HTTP requests?",
    "answer": "Call.cancel()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Call.stop()",
      "Call.abort()",
      "Call.cancel()",
      "OkHttpClient.cancel()",
      "Request.cancel()"
    ]
  },
  {
    "id": 284,
    "question": "Which operator in Flow collects only the latest value and cancels previous?",
    "answer": "collectLatest",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "collectLatest",
      "collect",
      "mapLatest",
      "latest",
      "takeLatest"
    ]
  },
  {
    "id": 285,
    "question": "Which coroutine builder is used for concurrent execution with deferred result?",
    "answer": "async",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "launch",
      "async",
      "runBlocking",
      "withContext",
      "concurrent"
    ]
  },
  {
    "id": 286,
    "question": "Which dispatcher is optimized for IO operations in coroutines?",
    "answer": "Dispatchers.IO",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Dispatchers.Default",
      "Dispatchers.Main",
      "Dispatchers.IO",
      "Dispatchers.Unconfined",
      "Dispatchers.Background"
    ]
  },
  {
    "id": 287,
    "question": "Which operator transforms emitted values in Flow?",
    "answer": "map",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "map",
      "filter",
      "collect",
      "flatMap",
      "transform"
    ]
  },
  {
    "id": 288,
    "question": "Which Flow operator allows combining emissions from multiple Flows?",
    "answer": "combine",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "zip",
      "merge",
      "combine",
      "concat",
      "flatCombine"
    ]
  },
  {
    "id": 289,
    "question": "Which Retrofit annotation is used for multipart requests?",
    "answer": "@Multipart",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@Multipart",
      "@FormData",
      "@MultiPartRequest",
      "@BodyPart",
      "@MultiRequest"
    ]
  },
  {
    "id": 290,
    "question": "Which annotation is used for sending file parts in Retrofit?",
    "answer": "@Part",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "@File",
      "@Part",
      "@Body",
      "@MultipartFile",
      "@Upload"
    ]
  },
  {
    "id": 291,
    "question": "Which operator collects Flow emissions on a different dispatcher than flow creation?",
    "answer": "flowOn",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "collectOn",
      "observeOn",
      "flowOn",
      "emitOn",
      "runOn"
    ]
  },
  {
    "id": 292,
    "question": "Which Flow operator skips the first n elements?",
    "answer": "drop(n)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "skip(n)",
      "drop(n)",
      "ignore(n)",
      "firstDrop(n)",
      "filter(n)"
    ]
  },
  {
    "id": 293,
    "question": "Which function in Retrofit is used to create a service interface?",
    "answer": "Retrofit.create(Service::class.java)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Retrofit.build(Service::class.java)",
      "Retrofit.create(Service::class.java)",
      "Retrofit.new(Service::class.java)",
      "Retrofit.generate(Service::class.java)",
      "Retrofit.service(Service::class.java)"
    ]
  },
  {
    "id": 294,
    "question": "Which operator in Flow combines emissions sequentially?",
    "answer": "flatMapConcat",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "flatMapMerge",
      "flatMapConcat",
      "combine",
      "zip",
      "merge"
    ]
  },
  {
    "id": 295,
    "question": "Which function converts a Flow to LiveData?",
    "answer": "asLiveData()",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "toLiveData()",
      "asLiveData()",
      "flowToLiveData()",
      "collectAsLiveData()",
      "toLive()"
    ]
  },
  {
    "id": 296,
    "question": "Which operator in Flow allows filtering emitted values?",
    "answer": "filter",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "filter",
      "map",
      "collect",
      "take",
      "distinct"
    ]
  },
  {
    "id": 297,
    "question": "Which OkHttp class handles HTTP authentication challenges?",
    "answer": "Authenticator",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Authenticator",
      "Interceptor",
      "Credentials",
      "AuthenticatorClient",
      "RequestHandler"
    ]
  },
  {
    "id": 298,
    "question": "How can you expose a Retrofit suspend function as a Kotlin Flow in your repository?",
    "answer": "fun fetchDataFlow(): Flow<Response<Type>> = flow { emit(api.fetchData()) }",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "fun fetchDataFlow(): Flow<Response<Type>> = flow { emit(api.fetchData()) }",
      "suspend fun fetchData(): Flow<Response<Type>>",
      "fun fetchDataAsync(): Flow<Response<Type>>",
      "fun fetchData(): LiveData<Response<Type>>",
      "fun fetchData(): Deferred<Response<Type>>"
    ]
  },
  {
    "id": 299,
    "question": "Which function in Retrofit returns a Call object for asynchronous execution?",
    "answer": "fun getData(): Call<Type>",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "fun getData(): Call<Type>",
      "suspend fun getData(): Response<Type>",
      "fun getDataAsync(): Deferred<Type>",
      "fun getData(): Flow<Type>",
      "fun getData(): Observable<Type>"
    ]
  },
  {
    "id": 300,
    "question": "Which exception in Retrofit indicates a conversion or parsing failure?",
    "answer": "JsonDataException or JsonParseException",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "IOException",
      "HttpException",
      "JsonDataException or JsonParseException",
      "NetworkException",
      "IllegalStateException"
    ]
  },
  {
    "id": 301,
    "question": "What is the key difference between `supervisorScope` and `coroutineScope`?",
    "answer": "A failure in a child coroutine within a `supervisorScope` does not affect other children, while in `coroutineScope` it cancels all siblings.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "A failure in a child coroutine within a `supervisorScope` does not affect other children, while in `coroutineScope` it cancels all siblings.",
      "`supervisorScope` cancels all children if one fails, whereas `coroutineScope` allows them to fail independently.",
      "`supervisorScope` is used for UI-related coroutines, and `coroutineScope` is for background work.",
      "There is no difference; `supervisorScope` is a deprecated name for `coroutineScope`.",
      "`supervisorScope` must be used with `Dispatchers.IO`, while `coroutineScope` works with any dispatcher."
    ]
  },
  {
    "id": 302,
    "question": "What is the primary difference between `StateFlow` and `SharedFlow`?",
    "answer": "`StateFlow` always has a value and only emits the latest state to new collectors, while `SharedFlow` is stateless and can be configured to replay multiple old values.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "`StateFlow` is a 'cold' flow, and `SharedFlow` is a 'hot' flow.",
      "`SharedFlow` is designed for representing UI state, while `StateFlow` is for one-time events.",
      "`StateFlow` always has a value and only emits the latest state to new collectors, while `SharedFlow` is stateless and can be configured to replay multiple old values.",
      "`StateFlow` must be collected within `viewModelScope`, but `SharedFlow` can be collected anywhere.",
      "You cannot update the value of a `SharedFlow`, only a `StateFlow`."
    ]
  },
  {
    "id": 303,
    "question": "What is the purpose of the `@JvmOverloads` annotation in Kotlin?",
    "answer": "It instructs the Kotlin compiler to generate overloaded versions of a function for Java consumers, based on default parameter values.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It allows a Kotlin function to be called from Java with a different name.",
      "It instructs the Kotlin compiler to generate overloaded versions of a function for Java consumers, based on default parameter values.",
      "It marks a function as being thread-safe for calls from both Java and Kotlin.",
      "It automatically converts Java types to Kotlin types in the function signature.",
      "It is used to expose a top-level function as a static method in Java."
    ]
  },
  {
    "id": 304,
    "question": "In Jetpack Compose, which modifier should be used to make a composable fill all available space within a `Row` or `Column` after its siblings have been measured?",
    "answer": "Modifier.weight(1f)",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Modifier.fillMaxSize()",
      "Modifier.weight(1f)",
      "Modifier.layoutId(\"fill\")",
      "Modifier.wrapContentSize(align = Alignment.Center, unbounded = true)",
      "Modifier.requiredSize(Size.Max)"
    ]
  },
  {
    "id": 305,
    "question": "What is the difference between `implementation`, `api`, and `compileOnly` dependency configurations in Gradle?",
    "answer": "`implementation` hides a dependency from consumers of a module, `api` exposes it transitively, and `compileOnly` makes it available only at compile time.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "`api` is for local modules, `implementation` is for remote libraries, and `compileOnly` is for test dependencies.",
      "`implementation` hides a dependency from consumers of a module, `api` exposes it transitively, and `compileOnly` makes it available only at compile time.",
      "`implementation` and `api` are identical, but `api` provides better build performance.",
      "`compileOnly` includes the dependency in the final APK, while `implementation` does not.",
      "`api` should be used for all dependencies to ensure they are available to other modules."
    ]
  },
  {
    "id": 306,
    "question": "What is the behavior of an Activity with the `singleTop` launch mode?",
    "answer": "If an instance of the Activity is already at the top of the back stack, a new instance will not be created; instead, its `onNewIntent()` method will be called.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It ensures that only one instance of the Activity can ever exist in the entire system.",
      "If an instance of the Activity is already at the top of the back stack, a new instance will not be created; instead, its `onNewIntent()` method will be called.",
      "It creates a new task and makes the Activity the root of that new task.",
      "It clears the entire task stack above it before creating a new instance.",
      "This launch mode is deprecated and should not be used in modern Android development."
    ]
  },
  {
    "id": 307,
    "question": "When should you use the Application Context instead of an Activity Context?",
    "answer": "When you need a context that is tied to the lifecycle of the entire application, such as for creating singletons or for tasks that outlive an Activity.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Always, because it prevents all types of memory leaks.",
      "When inflating UI layouts or accessing UI-related resources.",
      "When you need a context that is tied to the lifecycle of the entire application, such as for creating singletons or for tasks that outlive an Activity.",
      "Only in BroadcastReceivers and Services.",
      "There is no functional difference; they can be used interchangeably."
    ]
  },
  {
    "id": 308,
    "question": "What is the primary purpose of `DiffUtil` in the context of a `RecyclerView`?",
    "answer": "To calculate the difference between two lists and provide a set of update operations that allows the `RecyclerView.Adapter` to perform efficient and animated updates.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "To load data into the adapter from a remote or local data source.",
      "To handle item click and long-press events in a type-safe way.",
      "To create different view types within the same `RecyclerView`.",
      "To calculate the difference between two lists and provide a set of update operations that allows the `RecyclerView.Adapter` to perform efficient and animated updates.",
      "To define the layout and decoration of items, such as dividers and spacing."
    ]
  },
  {
    "id": 309,
    "question": "In Jetpack Compose, what problem does `CompositionLocal` solve?",
    "answer": "It allows data to be passed down the composable tree implicitly, without having to pass it as a parameter through every intermediate composable function.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It is used to store state that survives configuration changes, replacing `ViewModel`.",
      "It helps in creating complex animations between different composables.",
      "It allows data to be passed down the composable tree implicitly, without having to pass it as a parameter through every intermediate composable function.",
      "It defines the local position and size of a composable on the screen.",
      "It is a tool for debugging recomposition issues in Android Studio."
    ]
  },
  {
    "id": 310,
    "question": "For what purpose would you use a `callbackFlow` in Kotlin Coroutines?",
    "answer": "To convert callback-based APIs into a Flow, allowing them to be used in a reactive, coroutine-native way.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "To handle UI click event callbacks in Jetpack Compose.",
      "To create a simple flow that emits a fixed set of values.",
      "To ensure that a callback is always executed on the main thread.",
      "To convert callback-based APIs into a Flow, allowing them to be used in a reactive, coroutine-native way.",
      "It is a specialized flow for making network request callbacks with Retrofit."
    ]
  },
  {
    "id": 311,
    "question": "What is the role of Product Flavors in a Gradle build configuration?",
    "answer": "They are used to create different versions of your app (e.g., free vs. paid, or different branding) from the same codebase, allowing for different resources and code.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "They define the build process for debug and release versions of the app.",
      "They are used to manage different versions of dependencies for testing and production.",
      "They are used to create different versions of your app (e.g., free vs. paid, or different branding) from the same codebase, allowing for different resources and code.",
      "They control the ProGuard/R8 settings for code shrinking and obfuscation.",
      "They automatically generate different flavor icons for the app."
    ]
  },
  {
    "id": 312,
    "question": "What is a `BroadcastReceiver` and what is a common use case for it?",
    "answer": "It is an Android component that can listen for and respond to system-wide broadcast messages (e.g., network state change, battery low) or custom application events.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It is a long-running background process for tasks like playing music.",
      "It is a UI component used to receive input from the user.",
      "It is an Android component that can listen for and respond to system-wide broadcast messages (e.g., network state change, battery low) or custom application events.",
      "It is a networking client for receiving data from a server via broadcasts.",
      "It is used exclusively for receiving push notifications from Firebase."
    ]
  },
  {
    "id": 313,
    "question": "What distinguishes a Foreground Service from other types of Services?",
    "answer": "A Foreground Service must display a persistent notification to the user, and it is given higher priority by the system, making it less likely to be killed when memory is low.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It can only run when the application's UI is in the foreground.",
      "It runs on the main thread to perform quick UI-related background tasks.",
      "A Foreground Service must display a persistent notification to the user, and it is given higher priority by the system, making it less likely to be killed when memory is low.",
      "It is a special type of service that binds directly to an Activity's lifecycle.",
      "It does not require the `FOREGROUND_SERVICE` permission in the manifest."
    ]
  },
  {
    "id": 314,
    "question": "When testing coroutines, what is the main advantage of using `runTest` over `runBlocking`?",
    "answer": "`runTest` executes tests in a virtual-time environment, allowing delays and asynchronous operations to complete almost instantly, making tests faster and more reliable.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "`runTest` can only be used for testing UI-related coroutines, while `runBlocking` is for background logic.",
      "`runBlocking` blocks the main thread, while `runTest` does not.",
      "`runTest` executes tests in a virtual-time environment, allowing delays and asynchronous operations to complete almost instantly, making tests faster and more reliable.",
      "`runTest` is part of the JUnit 4 framework, whereas `runBlocking` is from JUnit 5.",
      "There is no advantage; they are interchangeable for testing purposes."
    ]
  },
  {
    "id": 315,
    "question": "In Jetpack Compose, what makes a class 'unstable' and why can it be a performance problem?",
    "answer": "A class is unstable if its properties are `var` or if it contains references to other unstable types. Unstable classes can cause composables that use them to be recomposed unnecessarily, even when the data hasn't actually changed.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "An unstable class is one that does not implement the `Parcelable` interface.",
      "A class is unstable if its properties are `var` or if it contains references to other unstable types. Unstable classes can cause composables that use them to be recomposed unnecessarily, even when the data hasn't actually changed.",
      "Unstable classes are those with more than five public methods, leading to slower compilation.",
      "A class is considered unstable if it is not annotated with `@Stable` or `@Immutable`.",
      "It refers to a class that is likely to cause runtime crashes due to its complexity."
    ]
  },
  {
    "id": 316,
    "question": "What is the Liskov Substitution Principle (LSP) and how can it apply to custom Android Views?",
    "answer": "Subtypes must be substitutable for their base types. For example, a custom `MyButton` subclassing `AppCompatButton` should function correctly wherever an `AppCompatButton` is expected, without causing unexpected behavior.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Subtypes must be substitutable for their base types. For example, a custom `MyButton` subclassing `AppCompatButton` should function correctly wherever an `AppCompatButton` is expected, without causing unexpected behavior.",
      "A class should only have one reason to change. For example, a custom View should only handle rendering, not business logic.",
      "High-level modules should depend on abstractions. For example, an Activity should depend on a `View` interface, not a concrete `MyButton`.",
      "Clients should not be forced to depend on interfaces they do not use.",
      "It is a principle for making classes open for extension but closed for modification."
    ]
  },
  {
    "id": 317,
    "question": "How does the Dependency Inversion Principle (DIP) relate to using Dependency Injection (DI) frameworks like Hilt?",
    "answer": "DIP states high-level modules should depend on abstractions, not concretions. DI frameworks like Hilt implement this by providing concrete implementations of these abstractions (e.g., a `UserRepositoryImpl` for a `UserRepository` interface) at runtime.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "DIP is about inverting control flow, while DI is about providing objects.",
      "DIP states high-level modules should depend on abstractions, not concretions. DI frameworks like Hilt implement this by providing concrete implementations of these abstractions (e.g., a `UserRepositoryImpl` for a `UserRepository` interface) at runtime.",
      "They are unrelated; DIP is an architectural principle while Hilt is just a library for reducing boilerplate.",
      "DIP is only applicable for inverting dependencies between UI layers, which Hilt does not manage.",
      "Hilt violates DIP by creating a direct dependency on the Dagger-Hilt framework."
    ]
  },
  {
    "id": 318,
    "question": "What is the Builder pattern and where is it commonly used in the Android SDK?",
    "answer": "It is a pattern for constructing complex objects step-by-step. It is used extensively in classes like `AlertDialog.Builder`, `NotificationCompat.Builder`, and `OkHttpClient.Builder`.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It is a pattern for constructing complex objects step-by-step. It is used extensively in classes like `AlertDialog.Builder`, `NotificationCompat.Builder`, and `OkHttpClient.Builder`.",
      "It is a pattern that ensures only one instance of a class exists, like a `Retrofit` singleton.",
      "It is a pattern for creating different types of objects from a single factory method, like in `ViewModelProvider.Factory`.",
      "It is a pattern for observing state changes, used in `LiveData`.",
      "It is a structural pattern for adapting one interface to another, like `RecyclerView.Adapter`."
    ]
  },
  {
    "id": 319,
    "question": "What is the Observer pattern and which Android Architecture Components are prime examples of it?",
    "answer": "It is a behavioral pattern where a subject notifies a list of observers about state changes. `LiveData` and Kotlin's `Flow` are prime examples.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It is a pattern where an object's behavior changes when its state changes. `ViewModel` is a prime example.",
      "It is a pattern to encapsulate a request as an object. `WorkManager` is a prime example.",
      "It is a behavioral pattern where a subject notifies a list of observers about state changes. `LiveData` and Kotlin's `Flow` are prime examples.",
      "It is a creational pattern for building objects step-by-step, like `NotificationCompat.Builder`.",
      "It is a pattern for ensuring a class has only one instance, like `RoomDatabase`."
    ]
  },
  {
    "id": 320,
    "question": "What is an 'ANR' (Application Not Responding) error, and what is its most common cause?",
    "answer": "A system dialog shown when the UI thread has been blocked for too long (e.g., 5 seconds for an input event). The most common cause is performing long-running work like networking or heavy database I/O on the main thread.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "A type of crash that occurs when a background thread throws an unhandled exception.",
      "A system dialog shown when the UI thread has been blocked for too long (e.g., 5 seconds for an input event). The most common cause is performing long-running work like networking or heavy database I/O on the main thread.",
      "A warning from StrictMode that you are leaking memory.",
      "An error that occurs when an application uses too much battery in the background.",
      "A lint error indicating that a layout is too complex and will perform poorly."
    ]
  },
  {
    "id": 321,
    "question": "How can you diagnose a memory leak in an Android app using modern tools?",
    "answer": "Using the Android Studio Memory Profiler to capture a heap dump and analyze it for detached objects, or by integrating the LeakCanary library in debug builds for automatic detection.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "By repeatedly opening and closing the app and seeing if it gets slower.",
      "Using the Android Studio Memory Profiler to capture a heap dump and analyze it for detached objects, or by integrating the LeakCanary library in debug builds for automatic detection.",
      "By using the Layout Inspector to check for deep view hierarchies.",
      "By adding `Thread.sleep()` calls to see where the application hangs.",
      "By reading Logcat for messages that explicitly say 'memory leak detected'."
    ]
  },
  {
    "id": 322,
    "question": "What is `StrictMode` and in which build type should it be enabled?",
    "answer": "A developer tool that detects accidental disk or network access on the main thread. It should only be enabled in debug builds to avoid crashing the app for release users.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "A security feature that enforces strict permissions. It should be enabled in all build types.",
      "A developer tool that detects accidental disk or network access on the main thread. It should only be enabled in debug builds to avoid crashing the app for release users.",
      "A code shrinker like R8 that makes the app more secure. It should only be enabled in release builds.",
      "A linter that enforces strict coding styles. It runs during the build process.",
      "A tool for profiling CPU usage. It should be used with the Android Studio Profiler."
    ]
  },
  {
    "id": 323,
    "question": "What is 'overdraw' and how can you visualize it?",
    "answer": "It's when the app draws the same pixel multiple times in a single frame. It can be visualized using the 'Debug GPU Overdraw' option in Developer Options, which colors pixels based on how many times they've been drawn.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It's when the app draws outside the screen bounds. It can be visualized with 'Show layout bounds'.",
      "It's when the app uses too much GPU memory. It can be visualized in the Memory Profiler.",
      "It's when the app draws the same pixel multiple times in a single frame. It can be visualized using the 'Debug GPU Overdraw' option in Developer Options, which colors pixels based on how many times they've been drawn.",
      "It's a delay in drawing the first frame of the app. It can be measured with Macrobenchmark.",
      "It's a visual glitch where UI elements overlap incorrectly. It must be found through manual testing."
    ]
  },
  {
    "id": 324,
    "question": "What is the primary function of R8 in the Android build process?",
    "answer": "To shrink (remove unused code), obfuscate (rename classes and members), and optimize the application's code to reduce APK size and make it harder to reverse-engineer.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "To compile Kotlin code into Java bytecode.",
      "To shrink (remove unused code), obfuscate (rename classes and members), and optimize the application's code to reduce APK size and make it harder to reverse-engineer.",
      "To manage dependencies and resolve version conflicts.",
      "To automatically generate Android Manifest files for different product flavors.",
      "To sign the final release APK with a keystore certificate."
    ]
  },
  {
    "id": 325,
    "question": "When and why should you use the Android Keystore system?",
    "answer": "To store and manage cryptographic keys in a hardware-backed container, making them very difficult to extract. It should be used for sensitive data like encryption keys or user authentication tokens.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "To store simple key-value pairs like user settings, as a replacement for SharedPreferences.",
      "To store API keys that are needed at build time in `build.gradle`.",
      "To store and manage cryptographic keys in a hardware-backed container, making them very difficult to extract. It should be used for sensitive data like encryption keys or user authentication tokens.",
      "To store the signing certificate used to sign your release APK.",
      "To cache large files like images and videos securely on disk."
    ]
  },
  {
    "id": 326,
    "question": "What is certificate pinning?",
    "answer": "A security mechanism where an app is configured to trust only a specific, predefined set of server certificates or public keys, preventing man-in-the-middle attacks even if a device's trusted CA is compromised.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "The process of pinning a specific version of a dependency in `build.gradle`.",
      "A security mechanism where an app is configured to trust only a specific, predefined set of server certificates or public keys, preventing man-in-the-middle attacks even if a device's trusted CA is compromised.",
      "The practice of storing the app signing certificate in the Android Keystore.",
      "A way to pin a notification to the top of the notification shade so it cannot be dismissed.",
      "A performance optimization where you pin a background thread to a specific CPU core."
    ]
  },
  {
    "id": 327,
    "question": "Why is storing sensitive keys in `build.gradle` or `strings.xml` considered insecure?",
    "answer": "Because these values are compiled directly into the APK and can be easily extracted by anyone who decompiles the application.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Because it can significantly slow down the build process.",
      "Because these files are publicly visible if the source code is on GitHub.",
      "Because these values are compiled directly into the APK and can be easily extracted by anyone who decompiles the application.",
      "Because there is a strict size limit on the values that can be stored there.",
      "Because it violates the Single Responsibility Principle by mixing configuration with code/resources."
    ]
  },
  {
    "id": 328,
    "question": "What is the difference between an Android App Bundle (AAB) and an APK?",
    "answer": "An AAB is a publishing format you upload to Google Play. Play then uses the AAB to generate and serve optimized APKs for each user's specific device configuration (e.g., screen density, CPU architecture).",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "An AAB is just a compressed folder of multiple APKs.",
      "An AAB is a publishing format you upload to Google Play. Play then uses the AAB to generate and serve optimized APKs for each user's specific device configuration (e.g., screen density, CPU architecture).",
      "An APK is for debug builds and an AAB is for release builds.",
      "You can install an AAB directly on a device, but you cannot install an APK.",
      "AAB is an older, deprecated format replaced by universal APKs."
    ]
  },
  {
    "id": 329,
    "question": "What is the purpose of the `buildSrc` directory in a Gradle project?",
    "answer": "It's a special directory for organizing build logic. Custom tasks, plugins, and dependencies defined here can be easily shared across all modules in the project, promoting build logic reuse.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It is where the application's main source code is stored.",
      "It is a directory for storing test-only source code and resources.",
      "It's a special directory for organizing build logic. Custom tasks, plugins, and dependencies defined here can be easily shared across all modules in the project, promoting build logic reuse.",
      "It is where Gradle caches downloaded dependencies.",
      "It is a deprecated feature and has been replaced by Version Catalogs."
    ]
  },
  {
    "id": 330,
    "question": "What are `buildConfigField` and `resValue` in `build.gradle` used for?",
    "answer": "`buildConfigField` generates a constant in the `BuildConfig.java` class, while `resValue` generates a resource value (e.g., a string). This allows for build-time configuration of code and resources.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "They are both used to define dependencies for different product flavors.",
      "`buildConfigField` generates a constant in the `BuildConfig.java` class, while `resValue` generates a resource value (e.g., a string). This allows for build-time configuration of code and resources.",
      "`buildConfigField` is for defining ProGuard rules, and `resValue` is for defining resource shrinking rules.",
      "They are interchangeable ways to add metadata to the `AndroidManifest.xml`.",
      "`buildConfigField` adds a value to `SharedPreferences`, while `resValue` adds it to the Room database."
    ]
  },
  {
    "id": 331,
    "question": "What is Continuous Integration (CI) in the context of Android development?",
    "answer": "The automated practice of merging all developer code changes into a central repository, after which automated builds and tests are run to detect integration issues early.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "The process of manually testing the app before every release.",
      "The automated practice of releasing a new version of the app to the Play Store every day.",
      "The automated practice of merging all developer code changes into a central repository, after which automated builds and tests are run to detect integration issues early.",
      "The practice of integrating multiple third-party SDKs into an application.",
      "A feature in Android Studio that continuously compiles your code as you type."
    ]
  },
  {
    "id": 332,
    "question": "What is a Gradle Version Catalog?",
    "answer": "A centralized, type-safe way to define and share dependencies and their versions across all modules in a project, improving maintainability and reducing errors.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "A log file that catalogs all the Gradle versions used to build a project.",
      "A plugin that automatically updates dependencies to their latest versions.",
      "A centralized, type-safe way to define and share dependencies and their versions across all modules in a project, improving maintainability and reducing errors.",
      "A feature in `buildSrc` for defining project-wide variables.",
      "A list of approved dependencies for a project, for security purposes."
    ]
  },
  {
    "id": 333,
    "question": "What are the main benefits of modularizing an Android application?",
    "answer": "Faster build times (due to parallel builds and caching), improved code organization and ownership, better scalability, and the ability to enable dynamic feature delivery.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It is required by Google Play for all new apps.",
      "It makes the final installed app run significantly faster on the user's device.",
      "Faster build times (due to parallel builds and caching), improved code organization and ownership, better scalability, and the ability to enable dynamic feature delivery.",
      "It automatically makes the application more secure by isolating features.",
      "The main benefit is reducing the final APK size to under 10MB."
    ]
  },
  {
    "id": 334,
    "question": "What is the difference between a library module and a dynamic feature module?",
    "answer": "A library module is always included in the base APK. A dynamic feature module can be downloaded on-demand after the initial app install, reducing the initial download size.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "There is no difference; the terms are used interchangeably.",
      "A library module is for Kotlin code, and a dynamic feature module is for Java code.",
      "A library module can be published to Maven Central, while a dynamic feature module cannot.",
      "A library module is always included in the base APK. A dynamic feature module can be downloaded on-demand after the initial app install, reducing the initial download size.",
      "Dynamic feature modules are deprecated in favor of Android App Bundles."
    ]
  },
  {
    "id": 335,
    "question": "What is the purpose of `IdlingResource` in Espresso tests?",
    "answer": "To signal to Espresso when the app is busy with asynchronous work (e.g., network calls). Espresso waits for the resource to become idle before performing UI actions and assertions, preventing flaky tests.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "To provide mock data to the UI during a test.",
      "To make tests run faster by idling the CPU between operations.",
      "To signal to Espresso when the app is busy with asynchronous work (e.g., network calls). Espresso waits for the resource to become idle before performing UI actions and assertions, preventing flaky tests.",
      "To identify UI resources like Views and Buttons by their ID.",
      "A resource used for managing the lifecycle of the test itself."
    ]
  },
  {
    "id": 336,
    "question": "What is the key difference between a local unit test (in `/test`) and an instrumented test (in `/androidTest`)?",
    "answer": "Local tests run on your computer's JVM and are fast, ideal for logic (e.g., in a ViewModel). Instrumented tests run on an Android device or emulator, which is required for testing code that uses Android Framework APIs.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Local tests are written in Java, while instrumented tests must be written in Kotlin.",
      "Local tests run on your computer's JVM and are fast, ideal for logic (e.g., in a ViewModel). Instrumented tests run on an Android device or emulator, which is required for testing code that uses Android Framework APIs.",
      "Local tests are for testing UI, while instrumented tests are for testing business logic.",
      "Local tests do not require JUnit, but instrumented tests do.",
      "Only instrumented tests can use mocking libraries like MockK or Mockito."
    ]
  },
  {
    "id": 337,
    "question": "When would you use UI Automator instead of Espresso for UI testing?",
    "answer": "When you need to test user flows that interact with the system UI or other apps (e.g., verifying a notification appears or interacting with the Settings app), as Espresso is limited to your app's process.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "UI Automator is a simpler, lightweight version of Espresso for basic tests.",
      "When you need to test user flows that interact with the system UI or other apps (e.g., verifying a notification appears or interacting with the Settings app), as Espresso is limited to your app's process.",
      "Espresso is for testing Views, and UI Automator is for testing Jetpack Compose.",
      "UI Automator is used for automating unit tests, not UI tests.",
      "You should always use UI Automator because it is more powerful than Espresso."
    ]
  },
  {
    "id": 338,
    "question": "In MockK, what is the difference between `mockk()` and `spyk()`?",
    "answer": "`mockk()` creates a pure mock where all functions do nothing unless explicitly stubbed. `spyk()` wraps a real object, so it will call the real methods by default unless a specific method is stubbed.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "`mockk()` is for classes, and `spyk()` is for interfaces.",
      "`mockk()` creates a pure mock where all functions do nothing unless explicitly stubbed. `spyk()` wraps a real object, so it will call the real methods by default unless a specific method is stubbed.",
      "`spyk()` is a 'strict' mock that throws an error for unstubbed calls, while `mockk()` is 'relaxed'.",
      "`mockk()` can be used in local tests, but `spyk()` can only be used in instrumented tests.",
      "There is no difference; `spyk()` is an alias for `mockk()`."
    ]
  },
  {
    "id": 339,
    "question": "What is a 'flaky test'?",
    "answer": "A test that passes and fails intermittently without any code changes. This is often caused by race conditions, reliance on timings, or unhandled asynchronous operations.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "A test that is written with incomplete assertions.",
      "A test that always fails and indicates a bug in the application code.",
      "A test that passes and fails intermittently without any code changes. This is often caused by race conditions, reliance on timings, or unhandled asynchronous operations.",
      "A test that runs very slowly and slows down the CI pipeline.",
      "A test that tests a trivial or unimportant part of the codebase."
    ]
  },
  {
    "id": 340,
    "question": "What is the relationship between `Handler`, `Looper`, and `MessageQueue`?",
    "answer": "Each thread can have one `Looper` that continuously processes a `MessageQueue`. A `Handler` is used to post messages or Runnables to that queue from any thread, which will then be executed on the Looper's thread.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "A `Handler` loops through a `MessageQueue` managed by a `Looper`.",
      "A `Looper` is a message, a `Handler` is the queue, and `MessageQueue` is the thread.",
      "Each thread can have one `Looper` that continuously processes a `MessageQueue`. A `Handler` is used to post messages or Runnables to that queue from any thread, which will then be executed on the Looper's thread.",
      "They are deprecated components replaced by Kotlin Coroutines.",
      "They are all part of the Binder IPC mechanism for cross-process communication."
    ]
  },
  {
    "id": 341,
    "question": "What is Binder in the context of the Android OS?",
    "answer": "The primary Inter-Process Communication (IPC) mechanism in Android. It allows different processes (e.g., an app and a system service) to communicate efficiently and securely.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "A UI data binding library for connecting layouts to data sources.",
      "A component used for binding an Activity to a background Service.",
      "The primary Inter-Process Communication (IPC) mechanism in Android. It allows different processes (e.g., an app and a system service) to communicate efficiently and securely.",
      "A security tool for binding an app's permissions to its signing key.",
      "A type of `RecyclerView.Adapter` for binding complex data models to views."
    ]
  },
  {
    "id": 342,
    "question": "What happens to an Activity during a configuration change (e.g., screen rotation), and how does a `ViewModel` survive it?",
    "answer": "The original Activity instance is destroyed and a new one is created. A `ViewModel` survives because its lifecycle is scoped to a `ViewModelStoreOwner` that is retained across this recreation, not to the Activity instance itself.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "The Activity is just paused and then resumed, and the `ViewModel` does nothing special.",
      "The Activity is destroyed and the `ViewModel` is saved to disk and then reloaded.",
      "The original Activity instance is destroyed and a new one is created. A `ViewModel` survives because its lifecycle is scoped to a `ViewModelStoreOwner` that is retained across this recreation, not to the Activity instance itself.",
      "The `ViewModel` is automatically saved in the `onSaveInstanceState` bundle.",
      "The Android OS prevents the `ViewModel` from being garbage collected using a static reference."
    ]
  },
  {
    "id": 343,
    "question": "What is the purpose of the `baseline-prof.txt` file?",
    "answer": "It contains a list of classes and methods used during critical user journeys (like app startup) that should be pre-compiled (AOT) to improve performance, especially reducing startup time.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It defines the baseline styles and themes for the application.",
      "It is a ProGuard/R8 configuration file for keeping certain classes during obfuscation.",
      "It contains a list of classes and methods used during critical user journeys (like app startup) that should be pre-compiled (AOT) to improve performance, especially reducing startup time.",
      "It is a text file that lists all baseline permissions the app requires.",
      "It is a report generated by the linter showing baseline code quality metrics."
    ]
  },
  {
    "id": 344,
    "question": "What is the role of the `SavedStateHandle` in a `ViewModel`?",
    "answer": "It is a key-value map that allows a `ViewModel` to save and restore its state, ensuring it can survive not just configuration changes but also system-initiated process death.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It is used to handle the saved state of UI widgets in a custom View.",
      "It provides a handle to the `onSaveInstanceState` Bundle from an Activity.",
      "It is a key-value map that allows a `ViewModel` to save and restore its state, ensuring it can survive not just configuration changes but also system-initiated process death.",
      "It is a mechanism for handling state within Jetpack Compose exclusively.",
      "It is a reference to a `Handler` on the main thread for saving state asynchronously."
    ]
  },
  {
    "id": 345,
    "question": "In Jetpack Compose, what is the difference between `remember` and `rememberSaveable`?",
    "answer": "`remember` keeps state across recompositions, but the state is lost on configuration change or process death. `rememberSaveable` also keeps state across recompositions but additionally saves and restores it across configuration changes and process death.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "`remember` is for mutable state, while `rememberSaveable` is for immutable state.",
      "`remember` keeps state across recompositions, but the state is lost on configuration change or process death. `rememberSaveable` also keeps state across recompositions but additionally saves and restores it across configuration changes and process death.",
      "`rememberSaveable` is a deprecated name for `remember`.",
      "`remember` is used in Activities, and `rememberSaveable` is used in Fragments.",
      "`rememberSaveable` stores the state in a `ViewModel`, while `remember` stores it in the composition."
    ]
  },
  {
    "id": 346,
    "question": "What is the primary goal of the `FLAG_ACTIVITY_REORDER_TO_FRONT` Intent flag?",
    "answer": "If an instance of the target Activity already exists in the task's back stack, this flag will bring that instance to the foreground instead of creating a new one, reordering the stack.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It clears the entire task stack and starts the new Activity as the root.",
      "It ensures the Activity is always launched at the front of a new task.",
      "If an instance of the target Activity already exists in the task's back stack, this flag will bring that instance to the foreground instead of creating a new one, reordering the stack.",
      "It reorders all activities in the stack alphabetically.",
      "It is used to bring a background app's task to the foreground."
    ]
  },
  {
    "id": 347,
    "question": "Why would you use a `ContentProvider`?",
    "answer": "To securely share a structured set of your app's data with other applications, managing access through a standard interface with permissions.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "To provide static content like images and strings within your own app.",
      "To provide a direct-access, high-performance database for your app's UI.",
      "To securely share a structured set of your app's data with other applications, managing access through a standard interface with permissions.",
      "It is the only way to store content on an SD card.",
      "It is a modern replacement for `SharedPreferences`."
    ]
  },
  {
    "id": 348,
    "question": "What is the purpose of an `AndroidManifest.xml` file?",
    "answer": "It is a required file that presents essential information about the app to the Android build tools, the Android OS, and Google Play, such as the app's components, permissions, and hardware/software features.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It is a file that contains all the string resources for the application.",
      "It is a build script, similar to `build.gradle`, for configuring the app.",
      "It is an optional file for providing metadata to Android Studio's editor.",
      "It is a required file that presents essential information about the app to the Android build tools, the Android OS, and Google Play, such as the app's components, permissions, and hardware/software features.",
      "It is where you declare all of your app's dependencies."
    ]
  },
  {
    "id": 349,
    "question": "What is the main difference between `LiveData.observe()` and `LiveData.observeForever()`?",
    "answer": "`observe()` is lifecycle-aware and automatically removes the observer when the provided `LifecycleOwner` is destroyed. `observeForever()` is not lifecycle-aware and requires manual removal of the observer via `removeObserver()` to prevent leaks.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "`observeForever()` receives updates even when the app is in the background, while `observe()` does not.",
      "`observe()` is for Activities and `observeForever()` is for Services.",
      "`observeForever()` is a deprecated method.",
      "`observe()` is lifecycle-aware and automatically removes the observer when the provided `LifecycleOwner` is destroyed. `observeForever()` is not lifecycle-aware and requires manual removal of the observer via `removeObserver()` to prevent leaks.",
      "`observe()` can only have one observer, while `observeForever()` allows multiple observers."
    ]
  },
  {
    "id": 350,
    "question": "What is the purpose of the `invalidate()` and `requestLayout()` methods on a View?",
    "answer": "`invalidate()` tells the system that the View's content needs to be redrawn (triggers `onDraw()`). `requestLayout()` indicates that the View's bounds have changed and it needs to be remeasured and redrawn (triggers `onMeasure()`, `onLayout()`, `onDraw()`).",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "`invalidate()` redraws the view, and `requestLayout()` re-inflates it from XML.",
      "They are identical methods; one is just an alias for the other.",
      "`requestLayout()` should be called from a background thread, while `invalidate()` must be called from the UI thread.",
      "`invalidate()` tells the system that the View's content needs to be redrawn (triggers `onDraw()`). `requestLayout()` indicates that the View's bounds have changed and it needs to be remeasured and redrawn (triggers `onMeasure()`, `onLayout()`, `onDraw()`).",
      "`invalidate()` is for custom views, while `requestLayout()` is for standard Android widgets."
    ]
  },
  {
    "id": 351,
    "question": "What are the three main phases of rendering a Jetpack Compose frame?",
    "answer": "Composition, Layout, and Drawing.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Initialization, Rendering, and Updating.",
      "Building, Measuring, and Displaying.",
      "State Calculation, UI Construction, and Event Handling.",
      "Composition, Layout, and Drawing.",
      "Inflation, Measurement, and Painting."
    ]
  },
  {
    "id": 352,
    "question": "What is the primary role of the Jetpack Compose compiler plugin?",
    "answer": "It transforms `@Composable` functions at compile time, adding extra parameters to track state and manage recomposition, making the declarative UI system possible.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It converts Kotlin code into the old Android View system for backward compatibility.",
      "It is only responsible for enabling the `@Preview` annotation in Android Studio.",
      "It transforms `@Composable` functions at compile time, adding extra parameters to track state and manage recomposition, making the declarative UI system possible.",
      "It optimizes layout performance at runtime by analyzing the UI tree.",
      "It is a linter that enforces Compose-specific coding conventions."
    ]
  },
  {
    "id": 353,
    "question": "Under what condition does Jetpack Compose decide to 'skip' the recomposition of a composable function?",
    "answer": "When the function's inputs are determined to be 'stable' and their values have not changed since the last composition.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It never skips recomposition; it always re-runs every function in the tree.",
      "When the composable is off-screen, regardless of its inputs.",
      "When the function is marked with a special `@Skip` annotation.",
      "When the function's inputs are determined to be 'stable' and their values have not changed since the last composition.",
      "Only when the data is provided by a `StateFlow` from a ViewModel."
    ]
  },
  {
    "id": 354,
    "question": "What is the purpose of the `snapshotFlow` function in Jetpack Compose?",
    "answer": "To convert one or more Compose `State<T>` objects into a cold Kotlin Flow, bridging the reactive Compose state system with the world of coroutines.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "To take a screenshot of the current composable and save it as a `Flow<Bitmap>`.",
      "To create a `StateFlow` directly from a composable function.",
      "To convert a `LiveData` object into a Flow within a composable's lifecycle.",
      "To create a snapshot of the current UI hierarchy for testing purposes.",
      "To convert one or more Compose `State<T>` objects into a cold Kotlin Flow, bridging the reactive Compose state system with the world of coroutines."
    ]
  },
  {
    "id": 355,
    "question": "What is the difference between a 'cold' and a 'warm' app startup?",
    "answer": "A cold start is when the app's process has not been created yet. A warm start is when the process is already running, but the Activity needs to be recreated (e.g., from the background).",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "A cold start is the very first time an app is launched after installation; all others are warm starts.",
      "A cold start is when the app is launched on a device with a cold CPU, and a warm start is on a device that has been running for a while.",
      "A cold start is when the app's process has not been created yet. A warm start is when the process is already running, but the Activity needs to be recreated (e.g., from the background).",
      "Cold starts are for debug builds, and warm starts are for release builds.",
      "There is no difference; the terms describe the same process of launching an app."
    ]
  },
  {
    "id": 356,
    "question": "For what kind of performance analysis are tools like Perfetto or Systrace used?",
    "answer": "For capturing and analyzing detailed, system-wide performance traces to diagnose complex issues like UI jank, threading problems, or slow app startup.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "For detecting memory leaks by analyzing heap dumps.",
      "For logging network requests and responses in detail.",
      "For analyzing the complexity of a Jetpack Compose UI hierarchy.",
      "For capturing and analyzing detailed, system-wide performance traces to diagnose complex issues like UI jank, threading problems, or slow app startup.",
      "For running automated UI tests and measuring their execution time."
    ]
  },
  {
    "id": 357,
    "question": "What is the recommended dependency direction between feature, data, and domain modules in a multi-module architecture?",
    "answer": "Feature modules depend on domain/data modules, but domain/data modules must not depend on feature modules. This creates a one-way dependency flow towards the core business logic.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "All modules should depend on each other to facilitate communication.",
      "Data modules should depend on feature modules to know where the data is displayed.",
      "Feature modules depend on domain/data modules, but domain/data modules must not depend on feature modules. This creates a one-way dependency flow towards the core business logic.",
      "Feature modules should only depend on other feature modules.",
      "The dependency direction does not matter as long as the code compiles."
    ]
  },
  {
    "id": 358,
    "question": "How does a `CoroutineExceptionHandler` work and in which coroutine builder is it effective?",
    "answer": "It's an element in a `CoroutineContext` that catches uncaught exceptions from top-level coroutines. It is effective for coroutines started with `launch`, but not with `async` (where exceptions are held in the `Deferred` result).",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It is a global handler that catches all exceptions in any coroutine.",
      "It is a replacement for a `try-catch` block inside a suspend function.",
      "It's an element in a `CoroutineContext` that catches uncaught exceptions from top-level coroutines. It is effective for coroutines started with `launch`, but not with `async` (where exceptions are held in the `Deferred` result).",
      "It only works with `supervisorScope` and is ignored otherwise.",
      "It is automatically installed by `viewModelScope` to prevent all crashes."
    ]
  },
  {
    "id": 359,
    "question": "What is a key conceptual difference between a Kotlin `Flow` and a `Channel`?",
    "answer": "A `Flow` is a cold stream representing a sequence of values over time, designed for a single collector. A `Channel` is a hot communication primitive (like a queue) that can be used for communication between multiple coroutines.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "`Flow` is for reactive UI updates, while `Channel` is for background threading.",
      "`Channel` is a deprecated component that has been fully replaced by `SharedFlow`.",
      "A `Flow` is synchronous, while a `Channel` is always asynchronous.",
      "A `Flow` can only emit one value, while a `Channel` can emit multiple values.",
      "A `Flow` is a cold stream representing a sequence of values over time, designed for a single collector. A `Channel` is a hot communication primitive (like a queue) that can be used for communication between multiple coroutines."
    ]
  },
  {
    "id": 360,
    "question": "What is the main advantage of using Robolectric for tests?",
    "answer": "It allows you to run tests that use Android Framework APIs on the local JVM without needing a device or emulator, making them significantly faster than instrumented tests.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It is the only framework that can test Jetpack Compose UI.",
      "It allows you to write UI tests in pure Java instead of Kotlin.",
      "It provides more powerful mocking capabilities than MockK or Mockito.",
      "It runs tests on a real device, providing higher fidelity than Espresso.",
      "It allows you to run tests that use Android Framework APIs on the local JVM without needing a device or emulator, making them significantly faster than instrumented tests."
    ]
  },
  {
    "id": 361,
    "question": "What is the purpose of a `-keep` rule in a ProGuard or R8 configuration file?",
    "answer": "To specify classes, methods, or fields that must not be removed (shrunk) or renamed (obfuscated) during the build process, which is essential for code that is accessed via reflection or JNI.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "To keep a specific version of a library and prevent Gradle from updating it.",
      "To keep a file or resource from being compressed in the final APK.",
      "To specify classes, methods, or fields that must not be removed (shrunk) or renamed (obfuscated) during the build process, which is essential for code that is accessed via reflection or JNI.",
      "To keep a background service running even when the app is closed.",
      "To keep the build cache from being cleared between builds."
    ]
  },
  {
    "id": 362,
    "question": "What is VSYNC and what is its role in the Android rendering pipeline?",
    "answer": "VSYNC is a timing signal from the display hardware (e.g., every 16.6ms for a 60Hz display) that synchronizes the app's frame rendering loop. The app aims to produce a frame in time for each VSYNC signal to achieve smooth animation without tearing.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It is a protocol for synchronizing data between a client and a server.",
      "It is a Gradle task for syncing project dependencies.",
      "VSYNC is a timing signal from the display hardware (e.g., every 16.6ms for a 60Hz display) that synchronizes the app's frame rendering loop. The app aims to produce a frame in time for each VSYNC signal to achieve smooth animation without tearing.",
      "It is a security feature that verifies the integrity of the vertical layout of an app.",
      "It is an API in `RecyclerView` for vertically synchronizing scroll positions."
    ]
  },
  {
    "id": 363,
    "question": "What is the primary benefit of using Gradle Convention Plugins (e.g., in `buildSrc` or included builds)?",
    "answer": "To centralize and share common build configuration logic (like applying plugins, setting up Android SDK versions, or configuring libraries) across multiple modules in a type-safe way, reducing boilerplate and errors in `build.gradle` files.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "They are required to enable product flavors and build types.",
      "They allow you to write Gradle scripts in Java instead of Groovy or Kotlin.",
      "To centralize and share common build configuration logic (like applying plugins, setting up Android SDK versions, or configuring libraries) across multiple modules in a type-safe way, reducing boilerplate and errors in `build.gradle` files.",
      "Their only purpose is to make the build process faster.",
      "They are a way to download plugins from sources other than the Gradle Plugin Portal."
    ]
  },
  {
    "id": 364,
    "question": "What is 'State Hoisting' in Jetpack Compose?",
    "answer": "It is the pattern of moving state from a composable to its caller. This makes the original composable stateless, more reusable, and easier to test, following the principle of 'state flows down, events flow up'.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "Lifting state from a Composable directly into a global singleton object.",
      "Automatically saving Composable state to the `SavedStateHandle`.",
      "It is the pattern of moving state from a composable to its caller. This makes the original composable stateless, more reusable, and easier to test, following the principle of 'state flows down, events flow up'.",
      "Hoisting a composable function higher up in the UI tree to give it more priority.",
      "The process by which the Compose compiler 'hoists' state variables into the composition tree."
    ]
  },
  {
    "id": 365,
    "question": "What is the purpose of the `key` composable in Jetpack Compose?",
    "answer": "To provide a stable and unique identifier for a composable or group of composables. This helps Compose understand how items have moved, been added, or been removed in a list, allowing it to correctly preserve `remember`ed state across recompositions.",
    "type": "MULTIPLE_CHOICE",
    "fakeOptions": [
      "It is used to store a cryptographic key for encrypting the composable's state.",
      "It is the primary key used when storing composable state in a Room database.",
      "It is a unique identifier used by UI testing frameworks like Espresso to find a specific composable.",
      "To provide a stable and unique identifier for a composable or group of composables. This helps Compose understand how items have moved, been added, or been removed in a list, allowing it to correctly preserve `remember`ed state across recompositions.",
      "It is used to listen for specific key presses from a physical keyboard."
    ]
  }
]